@@
   <form id="form" autocomplete="off">
       <label>Name</label>
       <input id="name" required placeholder="Your name"/>
       <label>Date of Birth</label>
       <input id="date" type="date" required/>
       <label>Time of Birth</label>
       <input id="time" type="time" required value="12:00"/>
+      <label>Time Zone (UTC Offset)</label>
+      <!-- Sri Lanka default +05:30 -->
+      <input id="tz" required placeholder="+05:30" value="+05:30" />
       <label>Latitude</label>
       <input id="lat" required placeholder="e.g. 6.9271" step="any" inputmode="decimal"/>
       <label>Longitude</label>
       <input id="lon" required placeholder="e.g. 79.8612" step="any" inputmode="decimal"/>
@@
-    async function getPlanetsFromHorizons(date, time, lat, lon) {
-      const dt = `${date}T${time}:00`;
-      const codes = planetCodes.map(p=>p.code).join(",");
-      const url = `https://ssd.jpl.nasa.gov/api/horizons.api?format=json&COMMAND='${codes}'&OBJ_DATA=NO&MAKE_EPHEM=YES&TABLE_TYPE=OBSERVER&START_TIME='${dt}'&STOP_TIME='${dt}'&STEP_SIZE='1 m'&QUANTITIES='1'&SITE_COORD='${lat},${lon},0'`;
-      const res = await fetch(url);
-      const json = await res.json();
-      if(!json.result) return null;
-      const lines = json.result.split('\n');
-      const planets = [];
-      for(let p of planetCodes){
-        const planetIdx = lines.findIndex(line=>line.includes(`Target body name: ${p.name}`));
-        if(planetIdx < 0) continue;
-        let dataLine = null;
-        for(let i=planetIdx; i<lines.length; ++i){
-          if(lines[i].includes('$$SOE')){
-            dataLine = lines[i+1];
-            break;
-          }
-        }
-        if(!dataLine) continue;
-        const parts = dataLine.trim().split(/\s+/);
-        const ra = parseFloat(parts[3]);
-        planets.push({
-          name: p.name,
-          longitude: ra
-        });
-      }
-      return planets;
-    }
+    // --- Helpers for TZ + RA/Dec→Ecliptic ---
+    function parseTZToMinutes(tzStr){
+      // Accepts "+05:30", "-07:00", "+5.5", "5:30" (assume + if no sign)
+      const s = tzStr.trim();
+      let sign = +1;
+      let z = s;
+      if (s.startsWith('-')) { sign = -1; z = s.slice(1); }
+      else if (s.startsWith('+')) { sign = +1; z = s.slice(1); }
+      if (z.includes(':')) {
+        const [h,m] = z.split(':').map(Number);
+        return sign * ((h||0)*60 + (m||0));
+      } else if (z.includes('.')) {
+        const f = parseFloat(z);
+        const h = Math.trunc(Math.abs(f));
+        const m = Math.round((Math.abs(f)-h)*60);
+        return sign * (h*60 + m);
+      } else {
+        const h = parseInt(z||'0',10);
+        return sign * (h*60);
+      }
+    }
+    function toUTCFromOffset(dateStr, timeStr, offsetMinutes){
+      // Treat given date/time as local in `offsetMinutes`, return ISO "YYYY-MM-DDTHH:MM:SS"
+      const [Y,Mo,D] = dateStr.split('-').map(Number);
+      const [h,m] = timeStr.split(':').map(Number);
+      const ms = Date.UTC(Y, (Mo||1)-1, D||1, h||0, m||0, 0) - offsetMinutes*60000;
+      return new Date(ms).toISOString().slice(0,19);
+    }
+    function parseRAtoDegrees(raStr){
+      const parts = raStr.trim().replace(/:/g," ").split(/\s+/).map(Number);
+      const H=parts[0]||0, M=parts[1]||0, S=parts[2]||0;
+      return (H + M/60 + S/3600) * 15;
+    }
+    function parseDecString(decStr){
+      const t = decStr.trim().replace(/:/g," ").split(/\s+/);
+      if (t.length===1 && !isNaN(parseFloat(t[0]))) return parseFloat(t[0]);
+      const neg = t[0].startsWith('-');
+      const d = Math.abs(parseFloat(t[0]))||0, m=parseFloat(t[1])||0, s=parseFloat(t[2])||0;
+      const val = d + m/60 + s/3600;
+      return neg ? -val : val;
+    }
+    function eqToEclLongitude(raDeg, decDeg){
+      const eps = 23.4392911 * Math.PI/180; // mean obliquity J2000
+      const ra = raDeg*Math.PI/180, dec = decDeg*Math.PI/180;
+      const sinL = Math.sin(ra)*Math.cos(eps) + Math.tan(dec)*Math.sin(eps);
+      const cosL = Math.cos(ra);
+      let lam = Math.atan2(sinL, cosL) * 180/Math.PI;
+      if (lam < 0) lam += 360;
+      return lam;
+    }
+    async function fetchPlanet(dtISO, lat, lon, code, name){
+      // NOTE: SITE_COORD order must be lon,lat,km
+      const url = `https://ssd.jpl.nasa.gov/api/horizons.api`+
+        `?format=json&MAKE_EPHEM=YES&TABLE_TYPE=OBSERVER&QUANTITIES='1'`+
+        `&START_TIME='${dtISO}'&STOP_TIME='${dtISO}'&STEP_SIZE='1 m'`+
+        `&SITE_COORD='${lon},${lat},0'&COMMAND='${code}'`;
+      const res = await fetch(url);
+      const json = await res.json();
+      const txt = json.result || "";
+      const lines = txt.split(/\r?\n/);
+      const iS = lines.findIndex(l=>l.includes('$$SOE'));
+      const iE = lines.findIndex((l,i)=> i>iS && l.includes('$$EOE'));
+      if (iS<0 || iE<0) return null;
+      const row = lines.slice(iS+1, iE).find(l=>/\S/.test(l)) || "";
+      // Try to pick RA (h m s) then Dec
+      const raMatch  = row.match(/\b(\d{1,2}[:\s]\d{1,2}[:\s]\d{1,2}(\.\d+)?)\b/);
+      const decMatch = row.match(/[+\-]?\d{1,2}(?::|\s)\d{1,2}(?::|\s)\d{1,2}(\.\d+)?|[+\-]?\d+\.\d+/g);
+      if (!raMatch || !decMatch) return null;
+      const raDeg  = parseRAtoDegrees(raMatch[1]);
+      const decDeg = parseDecString(decMatch[0]);
+      const eclLon = eqToEclLongitude(raDeg, decDeg);
+      return { name, longitude: eclLon };
+    }
+    async function getPlanetsFromHorizonsISO(dtISO, lat, lon){
+      const out = [];
+      for (const p of planetCodes){
+        const v = await fetchPlanet(dtISO, Number(lat), Number(lon), p.code, p.name);
+        if (v) out.push(v);
+      }
+      return out;
+    }
@@
-    document.getElementById('form').onsubmit = async function(e){
+    document.getElementById('form').onsubmit = async function(e){
       e.preventDefault();
       const formData = {
         name: document.getElementById('name').value.trim(),
         date: document.getElementById('date').value,
         time: document.getElementById('time').value,
+        tz:   document.getElementById('tz').value.trim(),
         lat: document.getElementById('lat').value,
         lon: document.getElementById('lon').value,
         place: document.getElementById('place').value.trim(),
         chartType: document.getElementById('chartType').value,
         ayanamsa: document.getElementById('ayanamsa').value,
         houseSystem: document.getElementById('houseSystem').value,
         showSubLords: document.getElementById('showSubLords').checked,
         showCuspDegrees: document.getElementById('showCuspDegrees').checked,
       };
       if(!(formData.name && formData.date && formData.time && formData.lat && formData.lon)){
         alert('Please fill all required fields.');
         return;
       }
       document.getElementById('analysis').innerHTML = "Calculating real planetary positions from NASA Horizons...";
-      let planets = await getPlanetsFromHorizons(formData.date, formData.time, formData.lat, formData.lon);
+      // Convert local birth time (with given TZ) → UTC ISO
+      const tzMinutes = parseTZToMinutes(formData.tz || "+00:00");
+      const dtISO = toUTCFromOffset(formData.date, formData.time, tzMinutes); // "YYYY-MM-DDTHH:MM:SS"
+      // Fetch per-planet (robust), SITE_COORD uses lon,lat,km
+      let planets = await getPlanetsFromHorizonsISO(dtISO, formData.lat, formData.lon);
       if(!planets || !planets.length){
         alert("Could not fetch planetary positions from NASA Horizons. Please check your details or try again later.");
         document.getElementById('analysis').innerHTML = "Error: Could not fetch planetary positions.";
         return;
       }
       drawKPWheelChart(planets);
       document.getElementById('analysis').innerHTML = getPlanetAnalysis(formData, planets);
     };
@@
-      txt += `<br><i>Note: Positions are astronomical (NASA Horizons, RA used as ecliptic longitude for demo). KP/Vedic options are UI only.</i>`;
+      txt += `<br><i>Note: Positions use NASA Horizons data, converted from RA/Dec → apparent ecliptic longitudes. KP/Vedic options are UI only.</i>`;
       return txt;
     }
