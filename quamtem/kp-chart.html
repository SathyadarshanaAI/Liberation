<script>
  // ---------- Utils ----------
  const $ = (id) => document.getElementById(id);
  const pob = $('pob');
  const suggest = $('pob-suggest');
  const latEl = $('lat');
  const lonEl = $('lon');
  const tzEl  = $('timezone');
  const statusEl = $('status');

  function setStatus(msg) { statusEl.textContent = msg || ''; }

  // Debounce helper
  function debounce(fn, wait=400) {
    let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), wait); };
  }

  // Format +05:30 from seconds
  function fmtOffsetFromSeconds(sec) {
    const sign = sec >= 0 ? '+' : '-';
    const abs = Math.abs(sec);
    const hr  = Math.floor(abs / 3600);
    const min = Math.round((abs % 3600) / 60);
    return `${sign}${String(hr).padStart(2,'0')}:${String(min).padStart(2,'0')}`;
  }

  // Fallback: browser timezone offset for today
  function browserOffsetNow() {
    const m = -new Date().getTimezoneOffset(); // minutes east of UTC
    const sign = m >= 0 ? '+' : '-';
    const am = Math.abs(m);
    const hr = Math.floor(am/60), min = am % 60;
    return `${sign}${String(hr).padStart(2,'0')}:${String(min).padStart(2,'0')}`;
  }

  // ---------- Timezone from lat/lon (Open-Meteo) ----------
  async function setTimeZoneFromLatLon(lat, lon) {
    if (!lat || !lon) return;
    try {
      setStatus('Detecting time zone…');
      const url = `https://api.open-meteo.com/v1/timezone?latitude=${lat}&longitude=${lon}`;
      const r = await fetch(url);
      const z = await r.json();
      if (z && typeof z.utc_offset_seconds === 'number') {
        tzEl.value = fmtOffsetFromSeconds(z.utc_offset_seconds);
        setStatus('✓ Time zone detected');
      } else {
        tzEl.value = browserOffsetNow();
        setStatus('Used browser time zone');
      }
    } catch {
      tzEl.value = browserOffsetNow();
      setStatus('Used browser time zone (offline)');
    }
  }

  // Try tz when both lat/lon are valid
  const tryTzFromLatLon = debounce(() => {
    const lat = parseFloat(latEl.value);
    const lon = parseFloat(lonEl.value);
    if (Number.isFinite(lat) && Number.isFinite(lon)) setTimeZoneFromLatLon(lat, lon);
  }, 500);

  latEl.addEventListener('input', tryTzFromLatLon);
  lonEl.addEventListener('input', tryTzFromLatLon);

  // ---------- OSM Autocomplete ----------
  pob.addEventListener('input', debounce(async function () {
    const query = pob.value.trim();
    if (query.length < 2) { suggest.style.display = 'none'; return; }
    const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=6&addressdetails=0`;
    const res = await fetch(url, { headers: { 'Accept-Language': 'en' } });
    const data = await res.json();
    suggest.innerHTML = '';
    data.forEach(place => {
      const li = document.createElement('li');
      li.textContent = place.display_name;
      li.onclick = () => {
        pob.value = place.display_name;
        latEl.value = parseFloat(place.lat).toFixed(4);
        lonEl.value = parseFloat(place.lon).toFixed(4);
        suggest.style.display = 'none';
        setTimeZoneFromLatLon(place.lat, place.lon);
      };
      suggest.appendChild(li);
    });
    suggest.style.display = data.length ? 'block' : 'none';
  }, 350));

  // Close suggestions when clicking outside
  document.addEventListener('click', e => {
    if (!suggest.contains(e.target) && e.target !== pob) suggest.style.display = 'none';
  });

  // If user typed a place but didn’t click a suggestion, resolve on blur/enter
  async function resolvePlaceToLatLonIfNeeded() {
    const q = pob.value.trim();
    if (!q) return;
    if (latEl.value && lonEl.value) return; // already set
    try {
      const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}&limit=1`;
      const r = await fetch(url);
      const [p] = await r.json();
      if (p) {
        latEl.value = parseFloat(p.lat).toFixed(4);
        lonEl.value = parseFloat(p.lon).toFixed(4);
        setTimeZoneFromLatLon(p.lat, p.lon);
      }
    } catch {}
  }
  pob.addEventListener('blur', resolvePlaceToLatLonIfNeeded);
  pob.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') { e.preventDefault(); resolvePlaceToLatLonIfNeeded(); }
  });

  // ---------- Demo table + wheel (unchanged) ----------
  const SIGNS = ['Aries','Taurus','Gemini','Cancer','Leo','Virgo','Libra','Scorpio','Sagittarius','Capricorn','Aquarius','Pisces'];
  function renderTable(planets) {
    const tbody = $('tbl'); tbody.innerHTML = '';
    (planets||[]).forEach(p => {
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${p.name}</td>
        <td>${Number(p.degree).toFixed(2)}</td>
        <td>${p.sign||''}</td>
        <td>${p.nakshatra||''}</td>
        <td>${p.pada||''}</td>
        <td>${p.starLord||''}</td>
        <td>${p.subLord||''}</td>`;
      tbody.appendChild(tr);
    });
  }
  function renderWheel(planets) {
    if (!planets?.length) { $('wheel').innerHTML = ''; return; }
    const W=270,H=270,Cx=W/2,Cy=H/2,R=98;
    let sectors='',labels='',planDots='';
    for (let i=0;i<12;i++){
      const a1=(i*30-90)*Math.PI/180, a2=((i+1)*30-90)*Math.PI/180;
      const x1=Cx+R*Math.cos(a1), y1=Cy+R*Math.sin(a1),
            x2=Cx+R*Math.cos(a2), y2=Cy+R*Math.sin(a2);
      sectors+=`<path d="M${Cx},${Cy} L${x1},${y1} A${R},${R} 0 0,1 ${x2},${y2} Z" fill="none" stroke="#2df3c2" stroke-width="1.4"/>`;
    }
    for (let i=0;i<12;i++){
      const a=((i*30+15)-90)*Math.PI/180, x=Cx+(R-16)*Math.cos(a), y=Cy+(R-16)*Math.sin(a);
      labels+=`<text x="${x}" y="${y+5}" font-size="13" fill="#60a5fa" text-anchor="middle" font-weight="bold">${SIGNS[i]}</text>`;
    }
    planets.forEach(p=>{
      const a=(p.degree-90)*Math.PI/180, r=R-30, x=Cx+r*Math.cos(a), y=Cy+r*Math.sin(a);
      planDots+=`<circle cx="${x}" cy="${y}" r="11" fill="#070c16" stroke="#e2f0ff" stroke-width="2"/><text x="${x}" y="${y+4}" font-size="11" fill="#2df3c2" text-anchor="middle" font-weight="bold">${p.name[0]}</text>`;
    });
    $('wheel').innerHTML =
      `<svg viewBox="0 0 ${W} ${H}" style="background:transparent;width:220px;height:220px;user-select:none;">
        <circle cx="${Cx}" cy="${Cy}" r="${R+9}" fill="rgba(7,18,34,0.98)" />${sectors}${labels}<g>${planDots}</g>
      </svg>`;
  }

  // ---------- Form submit (demo planets) ----------
  $('kpForm').onsubmit = async function(e){
    e.preventDefault();
    setStatus('Calculating…');
    const data = {
      planets: [
        {name:'Sun', degree:120.45, sign:'Cancer',     nakshatra:'Pushya',           pada:2, starLord:'Saturn',  subLord:'Mercury'},
        {name:'Moon',degree:203.22, sign:'Libra',      nakshatra:'Vishakha',         pada:3, starLord:'Jupiter', subLord:'Venus'},
        {name:'Mars',degree:48.30,  sign:'Taurus',     nakshatra:'Rohini',           pada:2, starLord:'Moon',    subLord:'Moon'},
        {name:'Mercury',degree:310.12,sign:'Aquarius', nakshatra:'Purva Bhadrapada', pada:1, starLord:'Jupiter', subLord:'Mercury'}
      ]
    };
    renderTable(data.planets);
    renderWheel(data.planets);
    setStatus('✓ Chart generated!');
  };

  // ---------- On load: set a sensible default TZ ----------
  window.addEventListener('DOMContentLoaded', () => {
    if (!tzEl.value) tzEl.value = browserOffsetNow();
  });
</script>
