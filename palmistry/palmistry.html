<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Palmistry ‚Äì High-Clarity 2D Overlay (Pro)</title>
<style>
:root{--pri:#16f0a7;--sec:#38bdf8;--bg:#0b0f16}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:#e6f0ff;font-family:system-ui,Segoe UI,Inter,Arial,sans-serif;text-align:center}
h1{margin:16px 0 8px}
.wrap{display:inline-block;position:relative;margin:10px auto}
video,canvas{width:92vw;max-width:460px;border-radius:16px;border:2px solid var(--pri);display:block;background:#0e1625}
.badge{position:absolute;left:8px;top:8px;padding:.25rem .45rem;border-radius:8px;font-size:.75rem;background:#0008}
.ghost{position:absolute;inset:0;width:100%;height:100%;opacity:.18;pointer-events:none}
.btns{margin:12px 0 6px;display:flex;gap:10px;justify-content:center;flex-wrap:wrap}
button{border:none;border-radius:10px;padding:.64em 1.05em;font-weight:700;cursor:pointer}
.flip{background:#16243a;color:#cfe9ff}
.cap{background:var(--sec);color:#07121f}
.enh{background:#16f0a7;color:#07121f}
.overlay{background:#93c5fd;color:#06131f}
.save{background:#fbbf24;color:#111827}
.torch{background:#22c55e;color:#052e16}
.sliderrow{margin:6px 0 14px;display:flex;gap:10px;justify-content:center;flex-wrap:wrap}
.chip{background:#0f172a;border:1px solid #1f2c48;border-radius:999px;padding:.25em .6em}
.sl{width:180px}
.note{color:#a6c8ff;margin:8px 12px}
footer{color:var(--pri);margin:18px 0 22px;font-size:.95em}
.legend{display:flex;gap:8px;justify-content:center;flex-wrap:wrap;margin-top:6px}
.legend span{display:inline-flex;align-items:center;gap:6px;font-size:.85rem;background:#0f172a;border:1px solid #1f2c48;border-radius:999px;padding:.2em .6em}
.dot{width:12px;height:12px;border-radius:50%;display:inline-block}
.hide{display:none !important}
</style>

<!-- OpenCV.js (primary + fallback) -->
<script>
(function(){
  const s=document.createElement('script');
  s.src="https://docs.opencv.org/4.x/opencv.js"; s.async=true;
  s.onerror=()=>{
    const f=document.createElement('script');
    f.src="https://cdn.jsdelivr.net/npm/@techstark/opencv-js@4.9.0-1/opencv.min.js";
    f.async=true; document.head.appendChild(f);
  };
  document.head.appendChild(s);
})();
</script>
</head>
<body>
  <h1>üñêÔ∏è Palmistry ‚Äì High-Clarity 2D Overlay</h1>

  <div class="wrap">
    <!-- No autoplay: we start camera on first capture click -->
    <video id="cam" playsinline></video>
    <img class="ghost" src="https://i.ibb.co/1K7K0gF/palm-overlay-demo.png" alt="hand overlay"
         onerror="this.style.display='none'">
    <canvas id="cv"></canvas>
    <span id="status" class="badge">Loading OpenCV‚Ä¶</span>
  </div>

  <div class="legend">
    <span><i class="dot" style="background:#ff6b6b"></i>Main creases</span>
    <span><i class="dot" style="background:#06d6a0"></i>Fine lines</span>
    <span><i class="dot" style="background:#00e5ff"></i>Overlay</span>
  </div>

  <p class="note">
    Put a dark cloth behind your hand. Keep the palm flat and fill the frame.
    Use <b>Torch</b> if available. Workflow: <b>Capture</b> ‚Üí <b>Enhance</b> ‚Üí <b>Overlay</b>.
  </p>

  <div class="btns">
    <button class="flip"    id="flipBtn">‚Üî Flip</button>
    <button class="cap"     id="capBtn">üì∏ Capture (Hi-Res)</button>
    <button class="enh"     id="enhBtn" disabled>‚ú® Enhance</button>
    <button class="overlay" id="ovBtn"  disabled>üé® Toggle Overlay</button>
    <button class="save"    id="saveBtn" disabled>üíæ Save PNG</button>
    <button class="torch hide" id="torchBtn">üî¶ Torch</button>
  </div>

  <div class="sliderrow">
    <span class="chip">Edge: <input id="edge" class="sl" type="range" min="15" max="120" value="60"> <small id="edgeV">60</small></span>
    <span class="chip">Detail (Gabor): <input id="gabor" class="sl" type="range" min="7" max="23" step="2" value="15"> <small id="gaborV">15</small></span>
    <span class="chip">Gamma: <input id="gamma" class="sl" type="range" min="90" max="180" value="130"> <small id="gammaV">1.30</small></span>
  </div>

  <footer>¬© 2025 Lebaretion ¬∑ Sathyadarshana ‚Äî Palmistry 2D Pro</footer>

<script>
/* --------- DOM --------- */
const video   = document.getElementById('cam');
const canvas  = document.getElementById('cv');
const ctx     = canvas.getContext('2d');
const statusEl= document.getElementById('status');

const flipBtn = document.getElementById('flipBtn');
const capBtn  = document.getElementById('capBtn');
const enhBtn  = document.getElementById('enhBtn');
const ovBtn   = document.getElementById('ovBtn');
const saveBtn = document.getElementById('saveBtn');
const torchBtn= document.getElementById('torchBtn');

const edgeEl  = document.getElementById('edge');
const edgeV   = document.getElementById('edgeV');
const gaborEl = document.getElementById('gabor');
const gaborV  = document.getElementById('gaborV');
const gammaEl = document.getElementById('gamma');
const gammaV  = document.getElementById('gammaV');

/* --------- State --------- */
let flipped=false, captured=false, overlayOn=true;
let stream=null, track=null, torchOn=false;
let srcBGR=null, enhancedRGBA=null, overlayOut=null;

/* --------- Helpers --------- */
function fit(){
  const w=Math.min(460, Math.floor(innerWidth*0.92));
  const h=Math.floor(w*4/3);
  canvas.width=w; canvas.height=h;
}
addEventListener('resize', fit, {passive:true}); fit();

function uiSet(){
  edgeV.textContent = edgeEl.value;
  gaborV.textContent= gaborEl.value;
  gammaV.textContent= (gammaEl.value/100).toFixed(2);
}
['input','change'].forEach(ev=>{
  edgeEl.addEventListener(ev, uiSet);
  gaborEl.addEventListener(ev, uiSet);
  gammaEl.addEventListener(ev, uiSet);
});
uiSet();

/* --------- Camera control (start on demand) --------- */
async function ensureCamera(){
  if(stream) return;
  try{
    stream = await navigator.mediaDevices.getUserMedia({
      video:{
        facingMode:{ideal:'environment'},
        width:{ideal:4000}, height:{ideal:3000},    // request hi-res still
        frameRate:{ideal:15, max:30},
        focusMode:"continuous"                       // some browsers ignore
      },
      audio:false
    });
    video.srcObject=stream; await video.play();
    track = stream.getVideoTracks()[0];

    // Torch availability (Chrome/Android + supported devices)
    const caps = track.getCapabilities?.();
    if(caps && caps.torch){ torchBtn.classList.remove('hide'); }
  }catch(e){
    alert('Camera error: '+ e.message);
  }
}

flipBtn.onclick=()=>{ flipped=!flipped; video.style.transform=flipped?'scaleX(-1)':'none'; };

torchBtn.onclick=async()=>{
  if(!track) return;
  try{
    torchOn=!torchOn;
    await track.applyConstraints({advanced:[{torch:torchOn}]});
    torchBtn.textContent = torchOn?'üî¶ Torch (ON)':'üî¶ Torch';
  }catch{
    alert('Torch not supported on this device');
  }
};

/* --------- Capture (single hi-res still) --------- */
capBtn.onclick=async()=>{
  await ensureCamera();
  if(!video.videoWidth){ alert('Video not ready'); return; }

  // draw full sensor frame
  canvas.width = video.videoWidth;
  canvas.height= video.videoHeight;
  ctx.save();
  if(flipped){ ctx.translate(canvas.width,0); ctx.scale(-1,1); }
  ctx.drawImage(video,0,0,canvas.width,canvas.height);
  ctx.restore();

  // keep BGR copy for OpenCV
  if(srcBGR) srcBGR.delete();
  srcBGR = cv.imread(canvas);

  captured=true;
  enhBtn.disabled=false; ovBtn.disabled=false; saveBtn.disabled=false;
};

/* --------- OpenCV ready gate --------- */
(function waitCV(){
  const ok=()=>{statusEl.textContent='OpenCV ready';};
  const poll=()=> (window.cv && cv.Mat) ? ok() : setTimeout(poll,200);
  if(window.cv && cv.onRuntimeInitialized!==undefined){ cv.onRuntimeInitialized=ok; poll(); }
  else { poll(); }
})();

/* --------- Enhance Pipeline (2D high clarity) --------- */
enhBtn.onclick=()=>{
  if(!captured){ alert('Capture first'); return; }
  enhance();
  drawOutput();
};

function enhance(){
  // Source clone
  const src = srcBGR.clone();

  // 1) Convert ‚Üí Gray
  const gray = new cv.Mat();
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

  // 2) Bilateral filter (edge-preserving denoise)
  const bf = new cv.Mat();
  cv.bilateralFilter(gray, bf, 7, 60, 60);

  // 3) CLAHE
  const clahe = new cv.CLAHE(2.2, new cv.Size(8,8));
  clahe.apply(bf, bf);

  // 4) Gamma correction
  const g = gammaEl.value/100; // 1.30 default
  const bf32 = new cv.Mat(); bf.convertTo(bf32, cv.CV_32F, 1/255);
  const lut = new cv.Mat(bf.rows, bf.cols, cv.CV_32F);
  cv.pow(bf32, g, lut);
  const gamma8 = new cv.Mat(); lut.convertTo(gamma8, cv.CV_8U, 255);

  // 5) Gabor bank
  const ksize = (+gaborEl.value)|0, sigma=4.0, lambd=10.0, gammaVal=0.5, psi=0;
  const angles=[0,30,60,90,120,150];
  const gSum = new cv.Mat.zeros(gamma8.rows, gamma8.cols, cv.CV_32F);
  const resp = new cv.Mat();
  for(const d of angles){
    const th = d*Math.PI/180;
    const ker = cv.getGaborKernel(new cv.Size(ksize,ksize), sigma, th, lambd, gammaVal, psi, cv.CV_32F);
    cv.filter2D(gamma8, resp, cv.CV_32F, ker);
    cv.max(gSum, resp, gSum);
    ker.delete();
  }
  const g8 = new cv.Mat(); cv.normalize(gSum, gSum, 0,255, cv.NORM_MINMAX); gSum.convertTo(g8, cv.CV_8U);

  // 6) Adaptive threshold (local) + morphology
  const bin = new cv.Mat();
  const C = -(+(edgeEl.value)); // slider drives aggressiveness
  cv.adaptiveThreshold(g8, bin, 255, cv.ADAPTIVE_THRESH_MEAN_C, cv.THRESH_BINARY, 21, C);
  const k3 = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3,3));
  cv.morphologyEx(bin, bin, cv.MORPH_OPEN, k3);
  cv.morphologyEx(bin, bin, cv.MORPH_CLOSE, k3); // close small gaps

  // 7) Skeletonization (thinning ‚Üí 1px)
  const skel = skeletonize(bin);

  // 8) Colorize enhanced result + make overlay
  const linesRGBA = new cv.Mat();           // cyan overlay
  cv.cvtColor(skel, linesRGBA, cv.COLOR_GRAY2RGBA);
  const tint = new cv.Mat(linesRGBA.rows, linesRGBA.cols, linesRGBA.type(), [0,255,255,255]);
  cv.bitwise_and(tint, linesRGBA, linesRGBA);

  const out = new cv.Mat();
  cv.addWeighted(src, 1.0, linesRGBA, 1.0, 0, out);

  // keep for toggle
  if(enhancedRGBA) enhancedRGBA.delete();
  if(overlayOut)   overlayOut.delete();
  enhancedRGBA = linesRGBA;     // colored skeleton
  overlayOut   = out;           // blended output

  // cleanup (others)
  [src, gray, bf, clahe, bf32, lut, gamma8, gSum, resp, g8, bin, k3, skel, tint].forEach(m=>m.delete());
}

function drawOutput(){
  if(!overlayOut){ cv.imshow(canvas, srcBGR); return; }
  if(overlayOn){
    cv.imshow(canvas, overlayOut);
  }else{
    // show the colored skeleton alone on top of original still (side-by-side look)
    const base = srcBGR.clone();
    const out = new cv.Mat();
    cv.addWeighted(base, 0.3, enhancedRGBA, 1.0, 0, out);
    cv.imshow(canvas, out);
    base.delete(); out.delete();
  }
}

ovBtn.onclick=()=>{ overlayOn=!overlayOn; drawOutput(); };

saveBtn.onclick=()=>{
  const a=document.createElement('a');
  a.href=canvas.toDataURL('image/png'); a.download='palm_'+Date.now()+'.png'; a.click();
};

/* --------- Skeletonize (morphological thinning) --------- */
function skeletonize(bin){
  const el = cv.getStructuringElement(cv.MORPH_CROSS, new cv.Size(3,3));
  const sk = cv.Mat.zeros(bin.rows, bin.cols, cv.CV_8U);
  const tmp=new cv.Mat(), er=new cv.Mat();
  while(true){
    cv.erode(bin, er, el);
    cv.dilate(er, tmp, el);
    cv.subtract(bin, tmp, tmp);
    cv.bitwise_or(sk, tmp, sk);
    er.copyTo(bin);
    if(cv.countNonZero(bin)===0) break;
  }
  tmp.delete(); er.delete(); el.delete();
  return sk;
}
</script>
</body>
</html>
