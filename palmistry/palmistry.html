<!DOCTYPE html>
<html lang="si">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Palmistry AI Overlay — Sathyadarshana (FULL rear/selfie)</title>
<style>
:root{--pri:#16f0a7;--bg:#0b0f16;--neon:#00e5ff}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:#e6f0ff;font-family:system-ui;text-align:center}
h1{margin:14px 0 6px}
.wrap{position:relative;display:inline-block}
video,canvas{width:92vw;max-width:460px;border-radius:16px;border:2px solid var(--pri);display:block;margin:auto;background:#000}
svg.overlay{position:absolute;inset:0;pointer-events:none;opacity:.6}
.captureBtn{
 position:absolute;bottom:18px;left:50%;transform:translateX(-50%);
 width:86px;height:86px;border-radius:50%;border:none;background:#2196f3;color:#000;
 font-weight:700;box-shadow:0 0 15px #2196f333;cursor:pointer
}
.btns{margin:10px 0;display:flex;gap:8px;justify-content:center;flex-wrap:wrap}
button,.btnLike{border:none;border-radius:10px;padding:.6em 1em;font-weight:700;cursor:pointer}
.left{background:#16243a;color:#cfe9ff}
.an{background:var(--pri);color:#002}
.cap{background:#fbbf24;color:#111}
.torch{background:#22c55e;color:#021}
select.btnLike,input[type=file].btnLike{background:#19283f;color:#cfe9ff}
.sliderRow{display:flex;gap:12px;justify-content:center;align-items:center;flex-wrap:wrap;margin:10px 0 6px}
.sliderRow label{display:flex;gap:8px;align-items:center}
input[type=range]{accent-color:#16f0a7}
#status{margin:10px auto;padding:10px;border:1px dashed #355;border-radius:10px;color:#cfe;max-width:820px;display:none}
footer{color:var(--pri);margin:18px 0 22px;font-size:.9em}
</style>

<!-- OpenCV loader + fallback -->
<script>
(function(){
  let loaded=false;
  function load(url, onload){
    const s=document.createElement('script'); s.src=url; s.async=true;
    s.onload=onload; s.onerror=()=>console.warn('Load failed:',url);
    document.head.appendChild(s);
  }
  load("https://docs.opencv.org/4.x/opencv.js", ()=>{
    if(window.cv){ cv['onRuntimeInitialized']=()=>{ window.cvReady=true; console.log('✅ OpenCV ready'); }; loaded=true; }
  });
  setTimeout(()=>{
    if(!loaded || !window.cv){
      load("https://cdn.jsdelivr.net/npm/@techstark/opencv-js@4.9.0-1/opencv.min.js", ()=>{
        if(window.cv){ cv['onRuntimeInitialized']=()=>{ window.cvReady=true; console.log('✅ OpenCV fallback ready'); }; }
      });
    }
  }, 2000);
})();
</script>
</head>
<body>
<h1>🖐️ Palmistry AI Overlay</h1>
<p>Align palm → <b>Start/Choose</b> → <b>Capture</b> → <b>Analyze</b></p>

<div class="wrap">
  <video id="cam" playsinline muted></video>
  <canvas id="cv"></canvas>

  <!-- palm guide -->
  <svg class="overlay" viewBox="0 0 420 560" preserveAspectRatio="xMidYMid slice">
    <path d="M145 485c-55-35-78-139-19-190 6-45 8-90 29-98 
             22-9 34 33 34 79 0-52 16-96 37-95 21 1 22 47 17 98 
             7-50 24-89 43-85 19 4 19 54 9 101 8-43 25-73 42-67 
             16 6 14 49 0 96 24 22 36 71 21 110-21 55-80 74-213 51z"
          fill="none" stroke="var(--neon)" stroke-width="2" filter="drop-shadow(0 0 5px var(--neon))"/>
  </svg>

  <button class="captureBtn" id="capBtn">Capture</button>
</div>

<div class="btns">
  <button class="btnLike" id="startBtn">▶️ Start Camera</button>
  <select id="camsel" class="btnLike"></select>
  <button class="btnLike" id="cycleBtn">🔁 Cycle Camera</button>
  <input id="pick" type="file" accept="image/*" class="btnLike"/>
  <button class="left" id="flipBtn">🖐 Left · Right</button>
  <button class="torch" id="torchBtn" hidden>🔦 Torch</button>
  <button class="an" id="anBtn">✨ Analyze</button>
  <button class="cap" id="saveBtn">💾 Save</button>
  <button class="btnLike" id="clearBtn">🧹 Clear</button>
</div>

<div class="sliderRow">
  <label>Edge <input id="edge" type="range" min="30" max="120" value="70"></label>
  <label>Detail <input id="gk" type="range" min="3" max="15" step="2" value="9"></label>
</div>

<div id="status"></div>

<footer>© 2025 Sathyadarshana · Palmistry AI Overlay</footer>

<script>
/* ========================= CORE VARS ========================= */
const video = document.getElementById('cam'),
      canvas = document.getElementById('cv'),
      ctx    = canvas.getContext('2d');
const startBtn = document.getElementById('startBtn'),
      camsel   = document.getElementById('camsel'),
      cycleBtn = document.getElementById('cycleBtn'),
      pick     = document.getElementById('pick'),
      flipBtn  = document.getElementById('flipBtn'),
      torchBtn = document.getElementById('torchBtn'),
      capBtn   = document.getElementById('capBtn'),
      anBtn    = document.getElementById('anBtn'),
      saveBtn  = document.getElementById('saveBtn'),
      clearBtn = document.getElementById('clearBtn');
let stream=null, track=null, flipped=false, captured=false;
let camList=[], camIndex=0;
window.cvReady=false;
canvas.crossOrigin = video.crossOrigin = "anonymous";
function msg(t){ const s=document.getElementById('status'); s.textContent=t; s.style.display='block'; }

/* ======================= CAMERA HELPERS ====================== */
async function listCams(){
  const devs = await navigator.mediaDevices.enumerateDevices();
  camList = devs.filter(d=>d.kind==='videoinput');

  // rear-first order
  camList.sort((a,b)=>{
    const ra = /back|rear|environment|wide/i.test(a.label);
    const rb = /back|rear|environment|wide/i.test(b.label);
    if (ra && !rb) return -1; if (!ra && rb) return 1; return 0;
  });

  camsel.innerHTML='';
  camList.forEach((c,i)=>{
    const o=document.createElement('option');
    o.value=c.deviceId; o.textContent=c.label||`Camera ${i+1}`;
    camsel.appendChild(o);
  });
  camIndex=0; camsel.selectedIndex=0;
}

async function startCam(deviceId=null){
  if(stream){ stream.getTracks().forEach(t=>t.stop()); }

  let constraints = deviceId
    ? { video:{ deviceId:{exact:deviceId}, width:{ideal:1280}, height:{ideal:720} }, audio:false }
    : { video:{ facingMode:{exact:'environment'}, width:{ideal:1280}, height:{ideal:720} }, audio:false };

  try{
    stream = await navigator.mediaDevices.getUserMedia(constraints);
  }catch(e){
    if(!deviceId){
      try{ stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'environment' }, audio:false }); }
      catch{ stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'user' }, audio:false }); }
    }else{
      const alt = camList.find(c=>c.deviceId!==deviceId);
      if(alt){
        stream = await navigator.mediaDevices.getUserMedia({ video:{ deviceId:{exact:alt.deviceId} }, audio:false });
        camsel.value = alt.deviceId;
      }else{
        stream = await navigator.mediaDevices.getUserMedia({ video:true, audio:false });
      }
    }
  }

  video.srcObject = stream; await video.play();
  track = stream.getVideoTracks()[0];
  const caps = track.getCapabilities?.(); if(caps && 'torch' in caps) torchBtn.hidden=false;

  canvas.width  = video.videoWidth  || 1280;
  canvas.height = video.videoHeight || 720;

  // mirror only for clear "front" labels (unless user forced flip)
  const label = track.label || '';
  const isFront = /front|user|selfie/i.test(label);
  video.style.transform = (isFront && !flipped) ? 'scaleX(-1)' : (flipped?'scaleX(-1)':'none');

  msg(`✅ Camera: ${label||'Unknown'} — Capture → Analyze`);
}

/* ---- Start / Cycle wiring ---- */
startBtn.onclick = async ()=>{
  try{ await listCams(); const id = camsel.value || (camList[0]?.deviceId ?? null); await startCam(id); }
  catch(e){
    if(e.name==='NotAllowedError') msg('❌ Permission blocked. Address bar 🔒 → Site settings → Camera → Allow.');
    else if(e.name==='NotReadableError') msg('❌ Camera busy by another app. Close other camera/flash apps.');
    else msg('❌ Camera error: '+e.message);
  }
};
cycleBtn.onclick = async ()=>{
  if(!camList.length) await listCams();
  if(!camList.length) return msg('No cameras detected.');
  camIndex = (camIndex + 1) % camList.length;
  camsel.selectedIndex = camIndex;
  await startCam(camList[camIndex].deviceId);
};

/* ---- UI misc ---- */
flipBtn.onclick = ()=>{ flipped=!flipped; video.style.transform=flipped?'scaleX(-1)':'none'; };
torchBtn.onclick = async()=>{
  if(!track) return;
  try{ const st = track.getSettings(); await track.applyConstraints({advanced:[{torch: !st.torch}]}); }
  catch(e){ msg('Torch error: '+e.message); }
};

/* ======================== CAPTURE / LOAD ===================== */
capBtn.onclick = async ()=>{
  try{
    if(!stream){ msg('ℹ️ Start Camera first (හෝ Choose file).'); return; }
    canvas.width  = video.videoWidth  || canvas.width || 1280;
    canvas.height = video.videoHeight || canvas.height|| 720;
    ctx.save(); if(flipped){ ctx.translate(canvas.width,0); ctx.scale(-1,1); }
    ctx.drawImage(video,0,0,canvas.width,canvas.height);
    ctx.restore(); captured=true;
    msg('🖐️ Photo locked. ✨ Analyze කරන්න.');
  }catch(e){ msg('❌ Capture failed: '+e.message); }
};

pick.onchange = e=>{
  const file = e.target.files?.[0]; if(!file) return;
  const img=new Image(); img.onload=()=>{
    canvas.width=img.naturalWidth; canvas.height=img.naturalHeight;
    ctx.drawImage(img,0,0,canvas.width,canvas.height); captured=true;
    msg('🖼️ Photo loaded. ✨ Analyze ඔබන්න.');
  };
  img.onerror=()=>msg('❌ Image load failed.');
  img.src=URL.createObjectURL(file);
};

clearBtn.onclick = ()=>{ ctx.clearRect(0,0,canvas.width,canvas.height); captured=false; msg('🧹 Cleared. Ready.'); };
saveBtn.onclick  = ()=>{ if(!captured) return msg('Capture/Load first.');
  const a=document.createElement('a'); a.href=canvas.toDataURL('image/png'); a.download='palm_'+Date.now()+'.png'; a.click(); };

/* =========================== ANALYZE ========================= */
anBtn.onclick = ()=>{
  if(!captured) return alert('Capture or Choose Photo first');
  if(!window.cvReady) return alert('OpenCV is still loading…');
  analyzeV2();
};

function analyzeV2(){
  const edgeVal = parseInt(document.getElementById('edge').value, 10); // 30..120
  const gk = parseInt(document.getElementById('gk').value, 10) | 1;    // odd 3..15

  const src = cv.imread(canvas);
  const h = src.rows, w = src.cols;

  // gray + CLAHE + blur
  const gray = new cv.Mat();
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
  const clahe = new cv.CLAHE(2.0, new cv.Size(8,8));
  clahe.apply(gray, gray);
  cv.GaussianBlur(gray, gray, new cv.Size(gk, gk), 0, 0, cv.BORDER_DEFAULT);

  // edges via Canny
  const low = Math.max(10, edgeVal);
  const high = Math.min(255, Math.round(edgeVal * 2));
  const edges = new cv.Mat();
  cv.Canny(gray, edges, low, high);

  // bands
  const yHeart0 = 0,         yHeart1 = Math.round(h * 0.30);
  const yHead0  = yHeart1,   yHead1  = Math.round(h * 0.55);
  const yLife0  = yHead1,    yLife1  = h;

  function longestContour(y0, y1){
    const roi = edges.roi(new cv.Rect(0, y0, w, y1 - y0));
    const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3,3));
    cv.morphologyEx(roi, roi, cv.MORPH_OPEN, kernel);
    const contours = new cv.MatVector(), hier = new cv.Mat();
    cv.findContours(roi, contours, hier, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_NONE);

    let best=null, bestLen=0;
    for(let i=0;i<contours.size();i++){
      const c=contours.get(i), len=cv.arcLength(c,false);
      if(len>bestLen && len>40){ best=c; bestLen=len; }
    }
    const pts=[];
    if(best){
      const approx=new cv.Mat();
      cv.approxPolyDP(best, approx, 2.0, false);
      for(let i=0;i<approx.rows;i++){ const p=approx.intPtr(i); pts.push([p[0], p[1]+y0]); }
      approx.delete();
    }
    contours.delete(); hier.delete(); roi.delete(); kernel.delete();
    return pts;
  }

  const heartPts = longestContour(yHeart0,yHeart1);
  const headPts  = longestContour(yHead0 ,yHead1 );
  const lifePts  = longestContour(yLife0 ,yLife1 );

  function drawPoly(pts, bgr){
    if(!pts || pts.length<4) return;
    const col=new cv.Scalar(bgr[0],bgr[1],bgr[2],255);
    for(let i=1;i<pts.length;i++){
      cv.line(src,new cv.Point(pts[i-1][0],pts[i-1][1]),
                  new cv.Point(pts[i][0],  pts[i][1]), col, 4, cv.LINE_AA);
    }
  }
  drawPoly(heartPts,[ 60, 60,255]); // red-ish
  drawPoly(headPts ,[ 60,180,255]); // orange-ish
  drawPoly(lifePts ,[ 60,255,120]); // green-ish

  // faint cyan edges overlay
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      if(edges.ucharPtr(y,x)[0]){
        const px=src.ucharPtr(y,x);
        px[0]=Math.min(255, (px[0]*0.6 + 255*0.4)); // B
        px[1]=Math.min(255, (px[1]*0.6 + 255*0.4)); // G
      }
    }
  }

  cv.imshow(canvas, src);
  [src, gray, clahe, edges].forEach(m=>m.delete());
  msg('✅ Analyze complete. Edge='+edgeVal+' · Detail='+gk);
}
</script>
</body>
</html>
