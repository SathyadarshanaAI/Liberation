<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Palmistry – High-Clarity 2D Overlay</title>
<style>
:root{--pri:#16f0a7;--sec:#38bdf8}
*{box-sizing:border-box}
body{margin:0;background:#0b0f16;color:#e6f0ff;font-family:system-ui,Segoe UI,Inter,Arial,sans-serif;text-align:center}
h1{margin:16px 0 8px}
.wrap{display:inline-block;position:relative;margin:10px auto}
video,canvas{width:92vw;max-width:420px;border-radius:16px;border:2px solid var(--pri);display:block;background:#0e1625}
.ghost{position:absolute;inset:0;width:100%;height:100%;opacity:.22;pointer-events:none}
.btns{margin:12px 0 14px;display:flex;gap:10px;justify-content:center;flex-wrap:wrap}
button{border:none;border-radius:10px;padding:.6em 1.1em;font-weight:700;cursor:pointer}
.flip{background:#16243a;color:#cfe9ff}
.cap{background:var(--sec);color:#07121f}
.an{background:var(--pri);color:#07121f}
.save{background:#fbbf24;color:#111827}
.torch{background:#22c55e;color:#052e16}
.hint{color:#a6c8ff;margin:8px 0}
.badge{position:absolute;left:8px;top:8px;padding:.25rem .45rem;border-radius:8px;font-size:.75rem;background:#0008}
footer{color:var(--pri);margin:18px 0 22px;font-size:.95em}
.row{display:flex;gap:8px;justify-content:center;align-items:center;flex-wrap:wrap}
.chip{background:#0f172a;border:1px solid #1f2c48;border-radius:999px;padding:.25em .6em}
.sl{width:180px}
.legend{display:flex;gap:8px;justify-content:center;flex-wrap:wrap;margin-top:6px}
.legend span{display:inline-flex;align-items:center;gap:6px;font-size:.85rem;background:#0f172a;border:1px solid #1f2c48;border-radius:999px;padding:.2em .6em}
.dot{width:12px;height:12px;border-radius:999px;display:inline-block}
</style>

<!-- OpenCV primary + fallback -->
<script>
(function(){
  const s=document.createElement('script'); s.src="https://docs.opencv.org/4.x/opencv.js"; s.async=true;
  s.onerror=()=>{const f=document.createElement('script'); f.src="https://cdn.jsdelivr.net/npm/@techstark/opencv-js@4.9.0-1/opencv.min.js"; f.async=true; document.head.appendChild(f);};
  document.head.appendChild(s);
})();
</script>
</head>
<body>
<h1>🖐️ Palmistry – AI Overlay</h1>

<div class="wrap">
  <video id="cam" playsinline></video>
  <img class="ghost" src="https://i.ibb.co/1K7K0gF/palm-overlay-demo.png" alt="overlay" onerror="this.style.display='none'">
  <canvas id="cv"></canvas>
  <span id="status" class="badge">loading OpenCV…</span>
</div>

<div class="legend">
  <span><i class="dot" style="background:#ff6b6b"></i>Heart</span>
  <span><i class="dot" style="background:#ffd166"></i>Head</span>
  <span><i class="dot" style="background:#06d6a0"></i>Life</span>
  <span><i class="dot" style="background:#118ab2"></i>Fate</span>
  <span><i class="dot" style="background:#ef476f"></i>Marriage</span>
  <span><i class="dot" style="background:#00e5ff"></i>Sun</span>
</div>

<p class="hint">Align palm with overlay → <b>Capture</b> → <b>Analyze</b>. Use a dark cloth under the hand for best contrast.</p>

<div class="btns">
  <button class="flip"  id="flipBtn">↔️ Flip</button>
  <button class="cap"   id="capBtn">📸 Capture</button>
  <button class="an"    id="anBtn" disabled>✨ Analyze</button>
  <button class="save"  id="saveBtn" disabled>💾 Save PNG</button>
  <button class="torch" id="torchBtn" hidden>🔦 Torch</button>
</div>

<div class="row" style="margin-top:-6px">
  <span class="chip">Edge <input id="edge" class="sl" type="range" min="20" max="120" value="70"> <small id="edgev">70</small></span>
  <span class="chip">Detail <input id="gk"   class="sl" type="range" min="7" max="23" step="2" value="15"> <small id="gkv">15</small></span>
  <span class="chip">Sharpen <input id="shp" class="sl" type="range" min="0" max="200" value="120"> <small id="shpv">1.20</small></span>
  <span class="chip">Thin <input id="thin"  class="sl" type="range" min="1" max="20" value="8"> <small id="thinv">8</small></span>
</div>

<footer>© 2025 Lebaretion · Sathyadarshana – Palmistry AI Overlay</footer>

<script>
const video=document.getElementById('cam');
const canvas=document.getElementById('cv');
const ctx=canvas.getContext('2d');
const statusEl=document.getElementById('status');
const capBtn=document.getElementById('capBtn');
const flipBtn=document.getElementById('flipBtn');
const anBtn=document.getElementById('anBtn');
const saveBtn=document.getElementById('saveBtn');
const torchBtn=document.getElementById('torchBtn');

const edge=document.getElementById('edge'), edgev=document.getElementById('edgev');
const gk  =document.getElementById('gk'),   gkv  =document.getElementById('gkv');
const shp =document.getElementById('shp'),  shpv =document.getElementById('shpv');
const thin=document.getElementById('thin'), thinv=document.getElementById('thinv');

edge.oninput=()=>edgev.textContent=edge.value;
gk.oninput  =()=>gkv.textContent=gk.value;
shp.oninput =()=>shpv.textContent=(+shp.value/100).toFixed(2);
thin.oninput=()=>thinv.textContent=thin.value;

let flipped=false, captured=false, stream=null, track=null, torchOn=false;

function fit(){const w=Math.min(420,Math.floor(innerWidth*0.92)),h=Math.floor(w*4/3);canvas.width=w;canvas.height=h;}
addEventListener('resize',fit,{passive:true}); fit();

flipBtn.onclick=()=>{flipped=!flipped; video.style.transform=flipped?'scaleX(-1)':'none';};

async function ensureCamera(){
  if(stream) return;
  try{
    stream=await navigator.mediaDevices.getUserMedia({
      video:{facingMode:{ideal:'environment'}, width:{ideal:3840}, height:{ideal:2160}, frameRate:{ideal:15,max:30}},
      audio:false
    });
    video.srcObject=stream; await video.play();
    track=stream.getVideoTracks()[0];
    const caps=track.getCapabilities?.(); if(caps && caps.torch) torchBtn.hidden=false;
  }catch(e){ alert('Camera blocked: '+e.message); }
}

torchBtn.onclick=async()=>{
  if(!track) return; try{ torchOn=!torchOn; await track.applyConstraints({advanced:[{torch:torchOn}]}); torchBtn.textContent=torchOn?'🔦 Torch (ON)':'🔦 Torch'; }catch(e){ alert('Torch not supported'); }
};

capBtn.onclick=async()=>{
  await ensureCamera();
  if(!video.videoWidth) return alert('Video not ready');
  canvas.width=video.videoWidth; canvas.height=video.videoHeight;
  ctx.save(); if(flipped){ctx.translate(canvas.width,0); ctx.scale(-1,1);} ctx.drawImage(video,0,0,canvas.width,canvas.height); ctx.restore();
  captured=true; saveBtn.disabled=false; anBtn.disabled=false;
};

saveBtn.onclick=()=>{const a=document.createElement('a'); a.href=canvas.toDataURL('image/png'); a.download='palm_'+Date.now()+'.png'; a.click();};

(function waitCV(){
  const ok=()=>{statusEl.textContent='OpenCV ready';};
  const poll=()=> (window.cv && cv.Mat)? ok() : setTimeout(poll,200);
  if(window.cv && cv.onRuntimeInitialized!==undefined){cv.onRuntimeInitialized=ok; poll();} else poll();
})();

anBtn.onclick=()=>{
  if(!captured) return alert('Capture first');
  if(!window.cv||!cv.Mat) return alert('OpenCV not loaded');
  analyze();
};

function analyze(){
  const src=cv.imread(canvas);

  // --- grayscale + contrast ---
  const gray=new cv.Mat(); cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY);
  const clahe=new cv.CLAHE(2.2,new cv.Size(8,8)); clahe.apply(gray,gray);

  // --- unsharp mask (sharpen) ---
  const g=new cv.Mat(); cv.GaussianBlur(gray,g,new cv.Size(0,0),1.2,1.2,cv.BORDER_DEFAULT);
  const alpha=(+shp.value)/100; // 0..2
  cv.addWeighted(gray,1+alpha,g,-alpha,0,gray); g.delete();

  // --- bilateral to keep edges clean ---
  const bf=new cv.Mat(); cv.bilateralFilter(gray,bf,9,50,50,cv.BORDER_DEFAULT); gray.delete();

  // --- Gabor bank (detail slider controls kernel size) ---
  const ksize=(+gk.value)|0, sigma=4.0,lambd=10.0,gamma=0.5,psi=0;
  const degs=[0,20,40,60,80,100,120,140];
  const gSum=cv.Mat.zeros(bf.rows,bf.cols,cv.CV_32F), resp=new cv.Mat();
  for(const d of degs){const th=d*Math.PI/180; const ker=cv.getGaborKernel(new cv.Size(ksize,ksize),sigma,th,lambd,gamma,psi,cv.CV_32F); cv.filter2D(bf,resp,cv.CV_32F,ker); cv.max(gSum,resp,gSum); ker.delete();}
  const g8=new cv.Mat(); cv.normalize(gSum,gSum,0,255,cv.NORM_MINMAX); gSum.convertTo(g8,cv.CV_8U);
  bf.delete(); gSum.delete(); resp.delete();

  // --- hybrid threshold (Adaptive + Otsu) ---
  const binA=new cv.Mat(); cv.adaptiveThreshold(g8,binA,255,cv.ADAPTIVE_THRESH_MEAN_C,cv.THRESH_BINARY,21,-(+edge.value));
  const binO=new cv.Mat(); cv.threshold(g8,binO,0,255,cv.THRESH_BINARY+cv.THRESH_OTSU);
  const bin=new cv.Mat(); cv.bitwise_and(binA,binO,bin); binA.delete(); binO.delete(); g8.delete();

  // --- morphology: close (seal gaps) then open (remove dust) ---
  const k3=cv.getStructuringElement(cv.MORPH_RECT,new cv.Size(3,3));
  const k5=cv.getStructuringElement(cv.MORPH_RECT,new cv.Size(5,5));
  cv.morphologyEx(bin,bin,cv.MORPH_CLOSE,k3);
  cv.morphologyEx(bin,bin,cv.MORPH_OPEN,k3);
  cv.dilate(bin,bin,k3);

  // --- thinning (iterations controllable) ---
  const skel=thinning(bin,(+thin.value)|0);
  k3.delete(); k5.delete(); bin.delete();

  // --- colorize + overlay ---
  const rgba=new cv.Mat(); cv.cvtColor(skel,rgba,cv.COLOR_GRAY2RGBA);
  const tint=new cv.Mat(rgba.rows,rgba.cols,rgba.type(),[0,255,255,255]); // neon cyan
  cv.bitwise_and(tint,rgba,rgba);
  const out=new cv.Mat(); cv.addWeighted(src,1.0,rgba,1.0,0,out);
  cv.imshow(canvas,out);

  // cleanup
  clahe.delete(); skel.delete(); rgba.delete(); tint.delete(); out.delete(); src.delete();
}

// Zhang–Suen–style iterative thinning using morphology (fast & simple control)
function thinning(bin,iters){
  const el=cv.getStructuringElement(cv.MORPH_CROSS,new cv.Size(3,3));
  const sk=cv.Mat.zeros(bin.rows,bin.cols,cv.CV_8U), tmp=new cv.Mat(), er=new cv.Mat();
  let count=0;
  while(true){
    cv.erode(bin,er,el);
    cv.dilate(er,tmp,el);
    cv.subtract(bin,tmp,tmp);
    cv.bitwise_or(sk,tmp,sk);
    er.copyTo(bin);
    if(cv.countNonZero(bin)===0 || ++count>=iters) break;
  }
  tmp.delete(); er.delete(); el.delete();
  return sk;
}
</script>
</body>
</html>
