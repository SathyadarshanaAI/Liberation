<!DOCTYPE html>
<html lang="si">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Sathyadarshana ¬∑ Palmistry AI Overlay (Full)</title>
<style>
  :root{
    --bg:#0a0f1a; --panel:#101826; --ink:#e6f0ff; --neon:#29e0ff; --accent:#7af7c0;
  }
  *{box-sizing:border-box} body{margin:0;background:var(--bg);color:var(--ink);font:15px/1.4 system-ui,Segoe UI,Roboto,Arial}
  header{padding:10px 14px;border-bottom:1px solid #19304e;background:linear-gradient(180deg,#0b1322,#0a0f1a)}
  h1{margin:0;font-size:16px;letter-spacing:.3px}
  .wrap{max-width:860px;margin:10px auto;padding:10px}
  .stage{position:relative;border:2px solid #163255;border-radius:14px;overflow:hidden;background:#000}
  video,canvas{display:block;width:100%;height:auto}
  .glass{position:absolute;inset:0;pointer-events:none}
  .grid{position:absolute;inset:8px;border:2px solid rgba(41,224,255,.5);border-radius:10px}
  .controls{display:flex;flex-wrap:wrap;gap:10px;margin:12px 2px}
  .controls .btn{border:1px solid #284d78;background:#0f1b2d;color:#d9eeff;padding:9px 12px;border-radius:10px}
  .controls .btn:active{transform:scale(.98)}
  .pill{padding:7px 10px;border-radius:999px;background:#0b1a2a;border:1px solid #1f3a5f}
  .row{display:flex;gap:12px;align-items:center}
  .sl{appearance:none;width:160px;height:6px;border-radius:8px;background:#1a2f4b;outline:none}
  .sl::-webkit-slider-thumb{appearance:none;width:18px;height:18px;border-radius:50%;background:#2df3c2}
  .badge{padding:3px 8px;border:1px solid #26486f;border-radius:999px;background:#0b1b2b;color:#9fceff}
  footer{opacity:.7;text-align:center;margin:12px 0}
  .legend{position:absolute;left:10px;top:10px;display:flex;gap:8px;z-index:3}
  .chip{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;background:rgba(0,0,0,.45);backdrop-filter:blur(6px);border:1px solid #25466b}
  .dot{width:12px;height:12px;border-radius:50%}
  .dot.heart{background:#ff3b3b}.dot.head{background:#ffa533}.dot.life{background:#42ff6c}
</style>
</head>
<body>
<header><h1>‚ú® Palmistry AI Overlay ‚Äî Full (Edge ‚ñ∏ Skeleton ‚ñ∏ Curves)</h1></header>

<div class="wrap">
  <div class="stage" id="stage">
    <video id="cam" playsinline muted></video>
    <canvas id="overlay" class="glass"></canvas>
    <div class="grid glass"></div>
    <div class="legend glass">
      <span class="chip"><span class="dot heart"></span>Heart</span>
      <span class="chip"><span class="dot head"></span>Head</span>
      <span class="chip"><span class="dot life"></span>Life</span>
    </div>
  </div>

  <div class="controls">
    <div class="row">
      <button class="btn" id="flip">üñêÔ∏è Left ‚ñ∏ Right</button>
      <button class="btn" id="torch">üî¶ Torch</button>
      <button class="btn" id="capture">üì∏ Capture</button>
      <button class="btn" id="analyze">‚ú® Analyze</button>
      <button class="btn" id="clear">üßπ Clear</button>
      <button class="btn" id="save">üíæ Save</button>
    </div>
    <div class="row pill">
      <span class="badge">Edge</span>
      <input type="range" id="edge" class="sl" min="20" max="90" value="55">
      <span id="edgev">55</span>
      <span class="badge" style="margin-left:10px">Detail</span>
      <input type="range" id="detail" class="sl" min="1" max="5" value="3">
      <span id="detv">3</span>
    </div>
  </div>

  <footer>¬© 2025 Sathyadarshana ¬∑ Palmistry AI Overlay</footer>
</div>

<script>
/* ==========================================================
   PALMISTRY FULL ‚Äì camera + edge + skeleton + curve tracking
   All vanilla JS (no libs). Tested on Chrome/Android.
   ========================================================== */
const $ = s => document.querySelector(s);
const video = $('#cam'), cv = $('#overlay'), ctx = cv.getContext('2d');
let stream, track, facing = 'environment';

// camera
async function startCam(){
  if(stream){ stream.getTracks().forEach(t=>t.stop()); }
  stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:facing, width:{ideal:1280}, height:{ideal:720} }, audio:false});
  video.srcObject = stream; video.play();
  track = stream.getVideoTracks()[0];
  await new Promise(r=>video.onloadedmetadata=r);
  cv.width = video.videoWidth; cv.height = video.videoHeight;
}
startCam().catch(e=>alert(e.message));

// UI
$('#flip').onclick = ()=>{ facing = (facing==='user'?'environment':'user'); startCam(); };
$('#torch').onclick = async ()=>{
  try{
    const caps = track.getCapabilities?.();
    if(caps && 'torch' in caps){ 
      const st = track.getSettings();
      await track.applyConstraints({advanced:[{torch: !st.torch}]});
    }else alert('Torch not supported on this device/browser.');
  }catch(e){ alert('Torch error: '+e.message); }
};
$('#edge').oninput = e=>$('#edgev').textContent = e.target.value;
$('#detail').oninput = e=>$('#detv').textContent = e.target.value;
$('#capture').onclick = ()=> drawGuide();
$('#clear').onclick = ()=> { ctx.clearRect(0,0,cv.width,cv.height); drawGuide(); };
$('#save').onclick = ()=> savePNG();
$('#analyze').onclick = ()=> analyzeNow();

function savePNG(){
  const tmp = document.createElement('canvas');
  tmp.width = cv.width; tmp.height = cv.height;
  const tctx = tmp.getContext('2d');
  tctx.drawImage(video,0,0,tmp.width,tmp.height);
  tctx.drawImage(cv,0,0);
  const a = document.createElement('a');
  a.download = 'palmistry_overlay.png';
  a.href = tmp.toDataURL('image/png');
  a.click();
}

function getFrame(){
  const c = document.createElement('canvas'); c.width = cv.width; c.height = cv.height;
  c.getContext('2d').drawImage(video,0,0,c.width,c.height);
  return c.getContext('2d').getImageData(0,0,c.width,c.height);
}

// ---------- image ops ----------
function toGray(img){
  const {data,width:w,height:h}=img, g=new Uint8ClampedArray(w*h);
  for(let i=0,j=0;i<data.length;i+=4,j++) g[j]=data[i]*0.299+data[i+1]*0.587+data[i+2]*0.114;
  return {w,h,g};
}
function claheLike(arr,w,h){
  // simple local contrast normalize (tile 8x8)
  const tw=8, th=8, tileW=Math.max(1,Math.floor(w/tw)), tileH=Math.max(1,Math.floor(h/th));
  const out=new Uint8ClampedArray(arr.length);
  for(let ty=0;ty<th;ty++){
    for(let tx=0;tx<tw;tx++){
      const x0=tx*tileW, y0=ty*tileH, x1=Math.min(w,(tx+1)*tileW), y1=Math.min(h,(ty+1)*tileH);
      let min=255,max=0;
      for(let y=y0;y<y1;y++)for(let x=x0;x<x1;x++){ const v=arr[y*w+x]; if(v<min)min=v; if(v>max)max=v; }
      const range=Math.max(20,max-min); // clip
      for(let y=y0;y<y1;y++)for(let x=x0;x<x1;x++){ const v=arr[y*w+x]; out[y*w+x]=((v-min)*255)/range; }
    }
  }
  return out;
}
function blur3(arr,w,h,passes){
  let a = Float32Array.from(arr);
  const k=[1,2,1,2,4,2,1,2,1], norm=16;
  for(let p=0;p<passes;p++){
    const t=new Float32Array(w*h);
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        let s=0,i=0;
        for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){ s+=a[(y+dy)*w+(x+dx)]*k[i++]; }
        t[y*w+x]=s/norm;
      }
    }
    a=t;
  }
  return Uint8ClampedArray.from(a);
}
function sobelEdges(arr,w,h,thr){
  const mag=new Float32Array(w*h); let max=1;
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      const i=y*w+x;
      const gx = -arr[i-w-1]-2*arr[i-1]-arr[i+w-1] + arr[i-w+1]+2*arr[i+1]+arr[i+w+1];
      const gy = -arr[i-w-1]-2*arr[i-w]-arr[i-w+1] + arr[i+w-1]+2*arr[i+w]+arr[i+w+1];
      const m=Math.hypot(gx,gy); mag[i]=m; if(m>max)max=m;
    }
  }
  const T=thr*max, bin=new Uint8ClampedArray(w*h);
  for(let i=0;i<w*h;i++) bin[i]=mag[i]>T?1:0;
  return bin;
}
function zhangSuenThin(bin,w,h){
  // bin is 0/1; result 0/1 skeleton
  const img = Uint8Array.from(bin);
  let changed=true, pass=0;
  const N=(x,y)=>(
    img[(y-1)*w + x] + img[(y-1)*w + (x+1)] + img[y*w + (x+1)] +
    img[(y+1)*w + (x+1)] + img[(y+1)*w + x] + img[(y+1)*w + (x-1)] +
    img[y*w + (x-1)] + img[(y-1)*w + (x-1)]
  );
  const S=(x,y)=>{
    const p=[img[(y-1)*w+x], img[(y-1)*w+(x+1)], img[y*w+(x+1)], img[(y+1)*w+(x+1)], img[(y+1)*w+x], img[(y+1)*w+(x-1)], img[y*w+(x-1)], img[(y-1)*w+(x-1)]];
    let t=0; for(let i=0;i<8;i++) if(p[i]==0 && p[(i+1)%8]==1) t++; return t;
  };
  while(changed && pass<30){
    changed=false; const rem=[];
    // step 1
    for(let y=1;y<h-1;y++)for(let x=1;x<w-1;x++){
      const i=y*w+x; if(!img[i]) continue;
      const nn=N(x,y); const s=S(x,y);
      if(nn>=2 && nn<=6 && s==1 && (img[(y-1)*w+x]*img[y*w+(x+1)]*img[(y+1)*w+x]==0) && (img[y*w+(x+1)]*img[(y)*w+(x-1)]*img[(y-1)*w+x]==0)) rem.push(i);
    }
    if(rem.length){ changed=true; rem.forEach(i=>img[i]=0); }
    rem.length=0;
    // step 2
    for(let y=1;y<h-1;y++)for(let x=1;x<w-1;x++){
      const i=y*w+x; if(!img[i]) continue;
      const nn=N(x,y); const s=S(x,y);
      if(nn>=2 && nn<=6 && s==1 && (img[(y-1)*w+x]*img[y*w+(x-1)]*img[(y+1)*w+x]==0) && (img[(y-1)*w+x]*img[y*w+(x+1)]*img[y*w+(x-1)]==0)) rem.push(i);
    }
    if(rem.length){ changed=true; rem.forEach(i=>img[i]=0); }
    pass++;
  }
  return img;
}

// label connected paths and keep longest within vertical band
function pickLongestPath(skel,w,h,y0,y1){
  const seen=new Uint8Array(w*h); let best=null;
  const nbr=[[-1,-1],[0,-1],[1,-1],[-1,0],[1,0],[-1,1],[0,1],[1,1]];
  function walk(sx,sy){
    const stack=[[sx,sy]], pts=[];
    seen[sy*w+sx]=1;
    while(stack.length){
      const [x,y]=stack.pop(); pts.push([x,y]);
      for(const [dx,dy] of nbr){
        const nx=x+dx, ny=y+dy, idx=ny*w+nx;
        if(nx>0&&ny>y0&&nx<w-1&&ny<y1-1 && !seen[idx] && skel[idx]){ seen[idx]=1; stack.push([nx,ny]); }
      }
    }
    return pts;
  }
  for(let y=y0+1;y<y1-1;y++){
    for(let x=1;x<w-1;x++){
      const i=y*w+x;
      if(skel[i] && !seen[i]){ 
        const pts=walk(x,y);
        if(!best || pts.length>best.length) best=pts;
      }
    }
  }
  return best||[];
}

// draw utilities
function drawGuide(){
  ctx.clearRect(0,0,cv.width,cv.height);
  // bands
  const h=cv.height, w=cv.width;
  const yHeart=0, hHeart=Math.floor(h*0.30);
  const yHead =hHeart, hHead =Math.floor(h*0.25);
  const yLife =yHead+hHead, hLife =h-(yHead+hHead);

  ctx.globalAlpha=.28; ctx.fillStyle='#ff3b3b'; ctx.fillRect(0,yHeart,w,hHeart);
  ctx.fillStyle='#ffa533'; ctx.fillRect(0,yHead,w,hHead);
  ctx.fillStyle='#42ff6c'; ctx.fillRect(0,yLife,w,hLife);
  ctx.globalAlpha=1;

  ctx.strokeStyle='rgba(41,224,255,.6)'; ctx.lineWidth=2;
  ctx.strokeRect(6,6,w-12,h-12);

  ctx.font='18px system-ui'; ctx.lineWidth=3; ctx.strokeStyle='#000'; ctx.fillStyle='#fff';
  ctx.strokeText('Heart', 14, 26); ctx.fillText('Heart',14,26);
  ctx.strokeText('Head',  14, yHead+26); ctx.fillText('Head',14,yHead+26);
  ctx.strokeText('Life',  14, yLife+26); ctx.fillText('Life',14,yLife+26);
}
drawGuide();

// main analyze
function analyzeNow(){
  const edgeThr = Number($('#edge').value)/100;   // 0.2..0.9
  const passes  = Number($('#detail').value);     // 1..5

  const frame = getFrame();
  const {w,h,g:gr0} = toGray(frame);
  const g1 = claheLike(gr0,w,h);
  const g2 = blur3(g1,w,h,passes);
  const bin = sobelEdges(g2,w,h,edgeThr);
  const skel = zhangSuenThin(bin,w,h);

  // bands
  const yHeart=0, hHeart=Math.floor(h*0.30);
  const yHead =hHeart, hHead =Math.floor(h*0.25);
  const yLife =yHead+hHead, hLife =h-(yHead+hHead);

  const pHeart = pickLongestPath(skel,w,h,yHeart,yHeart+hHeart);
  const pHead  = pickLongestPath(skel,w,h,yHead, yHead+hHead);
  const pLife  = pickLongestPath(skel,w,h,yLife, yLife+hLife);

  // draw
  drawGuide(); // reset bands underlay
  drawPath(pHeart,'#ff3b3b',4);
  drawPath(pHead ,'#ffa533',4);
  drawPath(pLife ,'#42ff6c',4);
  // show thin edges (cyan) for context
  drawEdgesMask(bin,w,h);
}

function drawEdgesMask(bin,w,h){
  const img = ctx.createImageData(w,h);
  for(let i=0,j=0;i<bin.length;i++,j+=4){
    if(bin[i]){ img.data[j]=0; img.data[j+1]=255; img.data[j+2]=255; img.data[j+3]=140; }
  }
  ctx.putImageData(img,0,0);
}

function drawPath(pts,color,wid){
  if(!pts || pts.length<6) return;
  // simple polyline smooth
  pts.sort((a,b)=>a[1]-b[1] || a[0]-b[0]);
  ctx.lineJoin='round'; ctx.lineCap='round';
  ctx.strokeStyle='#000'; ctx.lineWidth=wid+2; ctx.beginPath();
  ctx.moveTo(pts[0][0],pts[0][1]);
  for(const [x,y] of pts) ctx.lineTo(x,y);
  ctx.stroke();

  ctx.strokeStyle=color; ctx.lineWidth=wid; ctx.beginPath();
  ctx.moveTo(pts[0][0],pts[0][1]);
  for(const [x,y] of pts) ctx.lineTo(x,y);
  ctx.stroke();
}
</script>
</body>
</html>
