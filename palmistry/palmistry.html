<!DOCTYPE html>
<html lang="si">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Palmistry AI Overlay</title>
<style>
:root{--pri:#16f0a7;--bg:#0b0f16;--neon:#00e5ff;}
body{margin:0;background:var(--bg);color:#e6f0ff;font-family:system-ui;text-align:center;}
h1{margin:14px 0 6px;}
.wrap{position:relative;display:inline-block;}
video,canvas{width:92vw;max-width:460px;border-radius:16px;border:2px solid var(--pri);display:block;margin:auto;background:#000;}
svg.overlay{position:absolute;inset:0;pointer-events:none;opacity:.6;}
.captureBtn{
 position:absolute;bottom:18px;left:50%;transform:translateX(-50%);
 width:86px;height:86px;border-radius:50%;border:none;background:#2196f3;color:#000;
 font-weight:700;box-shadow:0 0 15px #2196f333;cursor:pointer;
}
.btns{margin:10px 0;display:flex;gap:8px;justify-content:center;flex-wrap:wrap;}
button,.btnLike{border:none;border-radius:10px;padding:.6em 1em;font-weight:700;cursor:pointer;}
.left{background:#16243a;color:#cfe9ff;}
.an{background:var(--pri);color:#002;}
.cap{background:#fbbf24;color:#111;}
.torch{background:#22c55e;color:#021;}
select.btnLike,input[type=file].btnLike{background:#19283f;color:#cfe9ff;}
.sliderRow{display:flex;gap:12px;justify-content:center;align-items:center;flex-wrap:wrap;margin:10px 0 6px;}
.sliderRow label{display:flex;gap:8px;align-items:center;}
input[type=range]{accent-color:#16f0a7;}
#status{margin:10px auto;padding:10px;border:1px dashed #355;border-radius:10px;color:#cfe;max-width:820px;display:none;transition:opacity .3s;}
#status.loading{opacity:0.6;}
footer{color:var(--pri);margin:18px 0 22px;font-size:.9em;}
.langRow{display:flex;gap:10px;justify-content:center;align-items:center;margin-bottom:8px;}
.undoBtn{background:#ea4;color:#222;border-radius:50%;font-size:1.2em;padding:0.3em 0.6em;}
</style>
</head>
<body>
<h1>üñêÔ∏è Palmistry AI Overlay</h1>
<div class="langRow">
  <label><input type="radio" name="lang" value="si" checked> ‡∑É‡∑í‡∂Ç‡∑Ñ‡∂Ω</label>
  <label><input type="radio" name="lang" value="en"> English</label>
</div>
<p id="guide">Align palm ‚Üí <b>Start/Choose</b> ‚Üí <b>Capture</b> ‚Üí <b>Analyze</b></p>

<div class="wrap">
  <video id="cam" playsinline muted></video>
  <canvas id="cv"></canvas>
  <svg class="overlay" viewBox="0 0 420 560" preserveAspectRatio="xMidYMid slice">
    <path d="M145 485c-55-35-78-139-19-190 6-45 8-90 29-98 
             22-9 34 33 34 79 0-52 16-96 37-95 21 1 22 47 17 98 
             7-50 24-89 43-85 19 4 19 54 9 101 8-43 25-73 42-67 
             16 6 14 49 0 96 24 22 36 71 21 110-21 55-80 74-213 51z"
          fill="none" stroke="var(--neon)" stroke-width="2" filter="drop-shadow(0 0 5px var(--neon))"/>
  </svg>
  <button class="captureBtn" id="capBtn">Capture</button>
  <button class="undoBtn" id="undoBtn" title="Undo Mirror" style="display:none;">‚Ü©Ô∏è</button>
</div>

<div class="btns">
  <button class="btnLike" id="startBtn">‚ñ∂Ô∏è Start Camera</button>
  <select id="camsel" class="btnLike"></select>
  <button class="btnLike" id="cycleBtn">üîÅ Cycle Camera</button>
  <input id="pick" type="file" accept="image/*" class="btnLike"/>
  <button class="left" id="flipBtn">üñê Left ¬∑ Right</button>
  <button class="torch" id="torchBtn" hidden>üî¶ Torch</button>
  <button class="an" id="anBtn">‚ú® Analyze</button>
  <button class="cap" id="saveBtn">üíæ Save</button>
  <button class="btnLike" id="clearBtn">üßπ Clear</button>
</div>

<div class="sliderRow">
  <label>Edge <input id="edge" type="range" min="30" max="120" value="70"></label>
  <label>Detail <input id="gk" type="range" min="3" max="15" step="2" value="9"></label>
</div>

<div id="status"></div>
<footer>¬© 2025 Sathyadarshana ¬∑ Palmistry AI Overlay</footer>

<script>
/* ========================= LANGUAGE ========================= */
const MSGS = {
  si: {
    guide: "‡∂Ö‡∂≠ align ‡∂ö‡∂ª‡∂±‡∑ä‡∂± ‚Üí <b>Start/Choose</b> ‚Üí <b>Capture</b> ‚Üí <b>Analyze</b>",
    camPerm: "‚ùå ‡∂ö‡∑ê‡∂∏‡∂ª‡∑è ‡∂Ö‡∑Ä‡∑É‡∂ª ‡∂Ö‡∑Ä‡∑Å‡∑ä‚Äç‡∂∫‡∂∫‡∑í. Address bar üîí ‚Üí Site settings ‚Üí Camera ‚Üí Allow.",
    camBusy: "‚ùå ‡∂ö‡∑ê‡∂∏‡∂ª‡∑è ‡∂ë‡∂ö busy. ‡∑Ä‡∑ô‡∂±‡∂≠‡∑ä camera/flash app ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂Ö‡∂©‡∑î ‡∂ö‡∂ª‡∂±‡∑ä‡∂±.",
    camError: "‚ùå ‡∂ö‡∑ê‡∂∏‡∂ª‡∑è ‡∂Ø‡∑ù‡∑Ç‡∂∫‡∂ö‡∑ä: ",
    camNone: "‚ùå ‡∂ö‡∑ê‡∂∏‡∂ª‡∑è device ‡∂ë‡∂ö‡∂ö‡∑ä ‡∑Ñ‡∂∏‡∑î ‡∂±‡∑ú‡∑Ä‡∑î‡∂´‡∑è.",
    camReady: "‚úÖ ‡∂ö‡∑ê‡∂∏‡∂ª‡∑è ‡∑É‡∑è‡∂ª‡∑ä‡∂Æ‡∂ö‡∂∫‡∑í: ",
    torchError: "Torch error: ",
    photoLocked: "üñêÔ∏è Photo locked. ‚ú® Analyze ‡∂ö‡∂ª‡∂±‡∑ä‡∂±.",
    photoLoaded: "üñºÔ∏è Photo loaded. ‚ú® Analyze ‡∂î‡∂∂‡∂±‡∑ä‡∂±.",
    cleared: "üßπ Cleared. Ready.",
    opencvSlow: "‚è≥ OpenCV download ‡∑Ä‡∑ô‡∂±‡∑Ä‡∑è‚Ä¶ Wi-Fi / data ‡∂∂‡∂Ω‡∂±‡∑ä‡∂±.",
    opencvFail: "‚ùå OpenCV download fail. analyzePureJS fallback.",
    analyzeJS: "‚úÖ Analyze (Pure-JS fallback) ‡∑É‡∂∏‡∑ä‡∂¥‡∑ñ‡∂ª‡∑ä‡∂´‡∂∫‡∑í.",
    analyzeDone: "‚úÖ Analyze ‡∑É‡∂∏‡∑ä‡∂¥‡∑ñ‡∂ª‡∑ä‡∂´‡∂∫‡∑í (OpenCV).",
    analyzeErr: "‚ùå Analyze ‡∂Ö‡∑É‡∑è‡∂ª‡∑ä‡∂Æ‡∂ö‡∂∫‡∑í: ",
    captureFirst: "‚ùó‡∂¥‡∑Ö‡∂∏‡∑î‡∑Ä Capture ‡∑Ñ‡∑ù Choose Photo ‡∂ö‡∂ª‡∂±‡∑ä‡∂±.",
    canvasErr: "‚ùå Canvas size 0√ó0. Start Camera ‚Üí Capture ‡∂±‡∑ê‡∑Ä‡∂≠ ‡∂ö‡∂ª‡∂±‡∑ä‡∂±.",
    imgErr: "‚ùå Image load failed.",
    saveInapp: "‚ÑπÔ∏è In-app browser downloads block ‡∑Ä‡∑ô‡∂±‡∑ä‡∂± ‡∂¥‡∑î‡∑Ö‡∑î‡∑Ä‡∂±‡∑ä. Chrome/Firefox ‡∑Ä‡∂Ω‡∑í‡∂±‡∑ä open ‡∂ö‡∂ª‡∂±‡∑ä‡∂±.",
    saveFail: "‚ùå Save failed: ",
    saveUnsupported: "‚ùå Save unsupported. Long-press ‚Üí ‚ÄúSave image‚Äù ‡∑Ñ‡∑ù Chrome ‡∑Ä‡∂Ω‡∑í‡∂±‡∑ä ‡∂Ö‡∂ª‡∑í‡∂±‡∑ä‡∂±.",
    saveNo: "Capture/Load first.",
    undoMirror: "‚Ü©Ô∏è Undo Mirror"
  },
  en: {
    guide: "Align palm ‚Üí <b>Start/Choose</b> ‚Üí <b>Capture</b> ‚Üí <b>Analyze</b>",
    camPerm: "‚ùå Camera permission denied. Address bar üîí ‚Üí Site settings ‚Üí Camera ‚Üí Allow.",
    camBusy: "‚ùå Camera busy. Please close other camera/flash apps.",
    camError: "‚ùå Camera error: ",
    camNone: "‚ùå No camera device detected.",
    camReady: "‚úÖ Camera ready: ",
    torchError: "Torch error: ",
    photoLocked: "üñêÔ∏è Photo locked. ‚ú® Click Analyze.",
    photoLoaded: "üñºÔ∏è Photo loaded. ‚ú® Click Analyze.",
    cleared: "üßπ Cleared. Ready.",
    opencvSlow: "‚è≥ Downloading OpenCV‚Ä¶ Check Wi-Fi/data.",
    opencvFail: "‚ùå OpenCV download failed. Using pure-JS fallback.",
    analyzeJS: "‚úÖ Analyze (Pure-JS fallback) complete.",
    analyzeDone: "‚úÖ Analyze complete (OpenCV).",
    analyzeErr: "‚ùå Analyze failed: ",
    captureFirst: "‚ùóFirst Capture or Choose Photo.",
    canvasErr: "‚ùå Canvas size 0√ó0. Start Camera ‚Üí Capture again.",
    imgErr: "‚ùå Image load failed.",
    saveInapp: "‚ÑπÔ∏è In-app browser downloads may be blocked. Open in Chrome/Firefox.",
    saveFail: "‚ùå Save failed: ",
    saveUnsupported: "‚ùå Save unsupported. Long-press ‚Üí ‚ÄúSave image‚Äù or use Chrome.",
    saveNo: "Capture/Load first.",
    undoMirror: "‚Ü©Ô∏è Undo Mirror"
  }
};
let LANG = 'si';
const guide = document.getElementById('guide');
document.querySelectorAll('input[name="lang"]').forEach(radio=>{
  radio.onchange = ()=>{
    LANG = radio.value;
    guide.innerHTML = MSGS[LANG].guide;
    msg('', true); // clear status
  };
});

/* ========================= CORE VARS ========================= */
const video = document.getElementById('cam'),
      canvas = document.getElementById('cv'),
      ctx    = canvas.getContext('2d');
const startBtn = document.getElementById('startBtn'),
      camsel   = document.getElementById('camsel'),
      cycleBtn = document.getElementById('cycleBtn'),
      pick     = document.getElementById('pick'),
      flipBtn  = document.getElementById('flipBtn'),
      torchBtn = document.getElementById('torchBtn'),
      capBtn   = document.getElementById('capBtn'),
      undoBtn  = document.getElementById('undoBtn'),
      anBtn    = document.getElementById('anBtn'),
      saveBtn  = document.getElementById('saveBtn'),
      clearBtn = document.getElementById('clearBtn');
let stream=null, track=null, captured=false, origImg=null;
let camList=[], camIndex=0;
let isMirrored=false;          // mirror state (live & captured)
canvas.crossOrigin = video.crossOrigin = "anonymous";
function msg(t,clear){ const s=document.getElementById('status');
  if(clear||!t){ s.textContent=''; s.style.display='none'; s.classList.remove('loading'); return;}
  s.textContent=t; s.style.display='block'; s.classList.remove('loading');
}
function loadingMsg(t){ const s=document.getElementById('status'); s.textContent=t; s.style.display='block'; s.classList.add('loading'); }

/* ======================= CAMERA HELPERS ====================== */
async function listCams(){
  const devs = await navigator.mediaDevices.enumerateDevices();
  camList = devs.filter(d=>d.kind==='videoinput');
  camList.sort((a,b)=>{ const ra=/back|rear|environment|wide/i.test(a.label); const rb=/back|rear|environment|wide/i.test(b.label); return ra===rb?0:(ra?-1:1); });
  camsel.innerHTML=''; camList.forEach((c,i)=>{ const o=document.createElement('option'); o.value=c.deviceId; o.textContent=c.label||`Camera ${i+1}`; camsel.appendChild(o); });
  camIndex=0; camsel.selectedIndex=0;
}
async function startCam(deviceId=null){
  if(stream){ stream.getTracks().forEach(t=>t.stop()); }
  let constraints = deviceId
    ? { video:{ deviceId:{exact:deviceId}, width:{ideal:1280}, height:{ideal:720} }, audio:false }
    : { video:{ facingMode:{exact:'environment'}, width:{ideal:1280}, height:{ideal:720} }, audio:false };
  try{
    stream = await navigator.mediaDevices.getUserMedia(constraints);
  }catch(e){
    if(!deviceId){
      try{ stream=await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'environment' }, audio:false }); }
      catch{ stream=await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'user' }, audio:false }); }
    }else{
      const alt=camList.find(c=>c.deviceId!==deviceId);
      if(alt){ stream=await navigator.mediaDevices.getUserMedia({ video:{ deviceId:{exact:alt.deviceId} }, audio:false }); camsel.value=alt.deviceId; }
      else{ stream=await navigator.mediaDevices.getUserMedia({ video:true, audio:false }); }
    }
  }
  video.srcObject = stream; await video.play();
  track = stream.getVideoTracks()[0];
  const caps = track.getCapabilities?.(); if(caps && 'torch' in caps) torchBtn.hidden=false;
  canvas.width  = video.videoWidth  || 1280;
  canvas.height = video.videoHeight || 720;
  video.style.transform = isMirrored ? 'scaleX(-1)' : 'none';
  msg(MSGS[LANG].camReady + (track.label || 'Unknown'));
}
startBtn.onclick = async ()=>{
  loadingMsg('...');
  try{ await listCams(); const id=camsel.value || (camList[0]?.deviceId ?? null); await startCam(id); }
  catch(e){
    if(e.name==='NotAllowedError') msg(MSGS[LANG].camPerm);
    else if(e.name==='NotReadableError') msg(MSGS[LANG].camBusy);
    else msg(MSGS[LANG].camError + e.message);
  }
};
cycleBtn.onclick = async ()=>{
  if(!camList.length) await listCams();
  if(!camList.length) return msg(MSGS[LANG].camNone);
  camIndex = (camIndex + 1) % camList.length;
  camsel.selectedIndex = camIndex;
  await startCam(camList[camIndex].deviceId);
};
flipBtn.onclick = ()=>{
  isMirrored = !isMirrored;
  if (stream && !captured) {
    video.style.transform = isMirrored ? 'scaleX(-1)' : 'none';
  } else if (captured && origImg) {
    drawImage(origImg, true);
    undoBtn.style.display='inline-block';
  }
};
undoBtn.onclick = ()=>{
  isMirrored = false;
  if (captured && origImg) drawImage(origImg, false);
  undoBtn.style.display='none';
};
torchBtn.onclick = async()=>{ if(!track) return; try{ const st=track.getSettings(); await track.applyConstraints({advanced:[{torch:!st.torch}]}); }catch(e){ msg(MSGS[LANG].torchError + e.message); }};

/* ======================== CAPTURE / LOAD ===================== */
capBtn.onclick = async ()=>{
  try{
    if(!stream){ msg(MSGS[LANG].captureFirst); return; }
    if(!video.videoWidth || !video.videoHeight){ await new Promise(r=>setTimeout(r,120)); }
    canvas.width  = video.videoWidth  || 1280;
    canvas.height = video.videoHeight || 720;
    origImg = captureImage();
    drawImage(origImg, isMirrored);
    captured=true;
    undoBtn.style.display='none';
    msg(MSGS[LANG].photoLocked);
  }catch(e){ msg(MSGS[LANG].camError + e.message); }
};
function captureImage(){
  const tmp=document.createElement('canvas');
  tmp.width=canvas.width; tmp.height=canvas.height;
  const tctx=tmp.getContext('2d');
  tctx.drawImage(video,0,0,canvas.width,canvas.height);
  return tmp;
}
function drawImage(img, mirror){
  ctx.save();
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(mirror){
    ctx.translate(canvas.width,0); ctx.scale(-1,1);
  }
  ctx.drawImage(img,0,0);
  ctx.restore();
}
pick.onchange = e=>{
  const file=e.target.files?.[0]; if(!file) return;
  const img=new Image(); img.onload=()=>{
    canvas.width=img.naturalWidth; canvas.height=img.naturalHeight;
    origImg = document.createElement('canvas');
    origImg.width=canvas.width; origImg.height=canvas.height;
    origImg.getContext('2d').drawImage(img,0,0,canvas.width,canvas.height);
    drawImage(origImg, isMirrored);
    captured=true;
    undoBtn.style.display=isMirrored?'inline-block':'none';
    msg(MSGS[LANG].photoLoaded);
  };
  img.onerror=()=>msg(MSGS[LANG].imgErr); img.src=URL.createObjectURL(file);
};
clearBtn.onclick = ()=>{ ctx.clearRect(0,0,canvas.width,canvas.height); captured=false; origImg=null; undoBtn.style.display='none'; msg(MSGS[LANG].cleared); };

/* =========================== SAVE ============================ */
saveBtn.onclick = ()=>{
  if(!captured){ msg(MSGS[LANG].saveNo); return; }
  const ua = navigator.userAgent || '';
  const inApp = /FBAN|FBAV|Instagram|Line\/|WeChat|MiuiBrowser/i.test(ua);
  if (inApp) msg(MSGS[LANG].saveInapp);
  try{
    if (canvas.toBlob){
      canvas.toBlob((blob)=>{
        if(!blob){ return fallback(); }
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href=url; a.download='palm_'+Date.now()+'.png';
        document.body.appendChild(a); a.click(); a.remove();
        URL.revokeObjectURL(url);
      }, 'image/png', 0.92);
    }else{ fallback(); }
  }catch(e){ msg(MSGS[LANG].saveFail + (e.message||e)); }
  function fallback(){
    try{
      const a=document.createElement('a');
      a.href=canvas.toDataURL('image/png'); a.download='palm_'+Date.now()+'.png';
      document.body.appendChild(a); a.click(); a.remove();
    }catch(e){ msg(MSGS[LANG].saveUnsupported); }
  }
};

/* =================== OpenCV loader + fallback ================= */
(function(){
  let loaded=false, failTimeout;
  function load(url, onload){
    const s=document.createElement('script'); s.src=url; s.async=true;
    s.onload=onload; s.onerror=()=>console.warn('Load failed:',url);
    document.head.appendChild(s);
  }
  load("https://docs.opencv.org/4.x/opencv.js", ()=>{
    if(window.cv){ cv['onRuntimeInitialized']=()=>{ window.cvReady=true; }; loaded=true; }
  });
  setTimeout(()=>{
    if(!loaded || !window.cv){
      load("https://cdn.jsdelivr.net/npm/@techstark/opencv-js@4.9.0-1/opencv.min.js", ()=>{
        if(window.cv){ cv['onRuntimeInitialized']=()=>{ window.cvReady=true; }; }
      });
    }
  }, 2000);
  failTimeout = setTimeout(()=>{
    if(!window.cvReady){
      msg(MSGS[LANG].opencvSlow);
    }
  }, 4000);
  window.cvReady = false;
  let _cvResolve;
  window.cvReadyPromise = new Promise(r => (_cvResolve = r));
  function _markCvReady(){ if(!window.cvReady){ window.cvReady = true; _cvResolve(true); clearTimeout(failTimeout); } }
  Object.defineProperty(window, 'cv', {
    set(v){ this._cv=v; try{ v.onRuntimeInitialized=_markCvReady; }catch{} },
    get(){ return this._cv; }
  });
  setTimeout(()=>{
    if(!window.cvReady){
      msg(MSGS[LANG].opencvSlow);
    }
  }, 4000);
})();

/* =========================== ANALYZE ========================= */
anBtn.onclick = async ()=>{
  if(anBtn.disabled) return;
  if(!captured){ msg(MSGS[LANG].captureFirst); return; }
  if (!canvas.width || !canvas.height) {
    if (video.videoWidth && video.videoHeight){ canvas.width=video.videoWidth; canvas.height=video.videoHeight; }
    else { msg(MSGS[LANG].canvasErr); return; }
  }
  anBtn.disabled=true; loadingMsg('Analyzing...');
  try{
    await window.cvReadyPromise;
    if (window.cv && cv.Mat) { analyzeV2(); msg(MSGS[LANG].analyzeDone); }
    else { msg(MSGS[LANG].opencvFail); analyzePureJS(); msg(MSGS[LANG].analyzeJS); }
  }catch(e){
    msg(MSGS[LANG].analyzeErr + (e?.message||e));
    console.error(e);
  }
  anBtn.disabled=false;
};
/* ===== OpenCV version (bands + longest contours) ===== */
function analyzeV2(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const edgeVal = parseInt(document.getElementById('edge').value, 10); // 30..120
  const gk = parseInt(document.getElementById('gk').value, 10) | 1;    // odd 3..15
  const src = cv.imread(canvas); const h=src.rows, w=src.cols;
  const gray=new cv.Mat(); cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY);
  const clahe=new cv.CLAHE(2.0,new cv.Size(8,8)); clahe.apply(gray,gray);
  cv.GaussianBlur(gray,gray,new cv.Size(gk,gk),0,0,cv.BORDER_DEFAULT);

  const low=Math.max(10,edgeVal), high=Math.min(255,Math.round(edgeVal*2));
  const edges=new cv.Mat(); cv.Canny(gray,edges,low,high);

  const yH0=0, yH1=Math.round(h*0.30), yD0=yH1, yD1=Math.round(h*0.55), yL0=yD1, yL1=h;
  function longestContour(y0,y1){
    const roi=edges.roi(new cv.Rect(0,y0,w,y1-y0));
    const kernel=cv.getStructuringElement(cv.MORPH_RECT,new cv.Size(3,3));
    cv.morphologyEx(roi,roi,cv.MORPH_OPEN,kernel);
    const cs=new cv.MatVector(), hr=new cv.Mat(); cv.findContours(roi,cs,hr,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_NONE);
    let best=null,lenBest=0; for(let i=0;i<cs.size();i++){ const c=cs.get(i), L=cv.arcLength(c,false); if(L>lenBest&&L>40){best=c;lenBest=L;} }
    const pts=[]; if(best){ const ap=new cv.Mat(); cv.approxPolyDP(best,ap,2.0,false); for(let i=0;i<ap.rows;i++){ const p=ap.intPtr(i); pts.push([p[0],p[1]+y0]); } ap.delete(); }
    cs.delete(); hr.delete(); roi.delete(); kernel.delete(); return pts;
  }
  const pHeart=longestContour(yH0,yH1),(bgr[0],bgr[1],bgr[2],255);
    for(let i=1;i<pts.length;i++){ cv.line(src,new cv.Point(pts[i-1][0],pts[i-1][1]),new cv.Point(pts[i][0],pts[i][1]),col,4,cv.LINE_AA); } }
  drawPoly(pHeart,[ 60, 60,255]); drawPoly(pHead,[ 60,180,255]); drawPoly(pLife,[ 60,255,120]);
  for(let y=0;y<h;y++){ for(let x=0;x<w(255,(]*0+255.4[1.min(px[0.255*4)); }
 src); [src,gray,clahe,edges].forEach(m=>m.delete());
}
/* ===== PURE-JS FALLBACK (no OpenCV) ===== */
function analyzePureJS(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const edgeVal=parseInt(document.getElementById('edge').value,10);
  const detail=parseInt(document.getElementById('gk').value,10);
  const w=canvas.width, h=canvas.height, src=ctx.getImageData(0,0,w,h);
  function toGray(img){ const d=img.data,g=new Uint8ClampedArray(w*h); for(let i=0,j=0;i<d.length;i+=4,j++) g[j]=d[i]*0.299+d[i+1]*0.587+d[i+2]*0.114; return g; }
  function blur3(arr,passes){ let a=Float32Array.from(arr); const k=[1,2,1,2,4,2,1,2,1],norm=16;
    for(let p=0;p<passes;p++){ const t=new Float32Array(w*h);
      for(let y=1;y<h-1;y++) for(let x=1;x<w-1;x++){ let s=0,i=0; for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++) s+=a[(y+dy)*w+(x+dx)]*k[i++]; t[y*w+x]=s/norm; }
      a=t; } return Uint8ClampedArray.from(a); }
  function sobel(arr,thr){ const mag=new Float32Array(w*h); let max=1;
    for(let y=1;y<h-1;y++) for(let x=1;x<w-1;x++){ const i=y*w+x;
      const gx=-arr[i-w-1]-2*arr[i-1]-arr[i+w-1]+arr[i-w+1]+2*arr[i+1]+arr[i+w+1];
      const gy=-arr[i-w-1]-2*arr[i-w]-arr[i-w+1]+arr[i+w-1]+2*arr[i+w]+arr[i+w+1];
      const m=Math.hypot(gx,gy); mag[i]=m; if(m>max)max=m; }
    const T=thr*max, bin=new Uint8ClampedArray(w*h); for(let i=0;i<w*h;i++) bin[i]=mag[i]>T?1:0; return bin; }
  function thinZS(bin){ const img=Uint8Array.from(bin); let ch=true,pass=0;
    const N=(x,y)=>img[(y-1)*w+x]+img[(y-1)*w+x+1]+img[y*w+x+1]+img[(y+1)*w+x+1]+img[(y+1)*w+x]+img[(y+1)*w+x-1]+img[y*w+x-1]+img[(y-1)*w+x-1];
    const S=(x,y)=>{ const p=[img[(y-1)*w+x],img[(y-1)*w+x+1],img[y*w+x+1],img[(y+1)*w+x+1],img[(y+1)*w+x],img[(y+1)*w+x-1],img[y*w+x-1],img[(y-1)*w+x-1]]; let t=0; for(let i=0;i<8;i++) if(p[i]==0&&p[(i+1)%8]==1) t++; return t; };
    while(ch&&pass<30){ ch=false; const rem=[];
      for(let y=1;y<h-1;y++)for(let x=1;x<w-1;x++){ const i=y*w+x;if(!img[i])continue;const nn=N(x,y),s=S(x,y);
        if(nn>=2&&nn<=6&&s==1&&(img[(y-1)*w+x]*img[y*w+x+1]*img[(y+1)*w+x]==0)&&(img[y*w+x+1]*img[y*w+x-1]*img[(y-1)*w+x]==0)) rem.push(i);}
      rem.forEach(i=>img[i]=0); if(rem.length)ch=true; rem.length=0;
      for(let y=1;y<h-1;y++)for(let x=1;x<w-1;x++){ const i=y*w+x;if(!img[i])continue;const nn=N(x,y),s=S(x,y);
        if(nn>=2&&nn<=6&&s==1&&(img[(y-1)*w+x]*img[y*w+x-1]*img[(y+1)*w+x]==0)&&(img[(y-1)*w+x]*img[y*w+x+1]*img[y*w+x-1]==0)) rem.push(i);}
      rem.forEach(i=>img[i]=0); if(rem.length)ch=true; pass++; }
    return img; }
  function pickLongest(skel,y0,y1){ const seen=new Uint8Array(w*h); let best=null;
    const NB=[[-1,-1],[0,-1],[1,-1],[-1,0],[1,0],[-1,1],[0,1],[1,1]];
    function walk(sx,sy){ const st=[[sx,sy]],pts=[]; seen[sy*w+sx]=1;
      while(st.length){ const [x,y]=st.pop(); pts.push([x,y]);
        for(const [dx,dy] of NB){ const nx=x+dx,ny=y+dy,id=ny*w+nx;
          if(nx>0&&ny>y0&&nx<w-1&&ny<y1-1&&!seen[id]&&skel[id]){ seen[id]=1; st.push([nx,ny]); } } }
      return pts; }
    for(let y=y0+1;y<y1-1;y++) for(let x=1;x<w-1;x++){ const i=y*w+x;
      if(skel[i]&&!seen[i]){ const pts=walk(x,y); if(!best||pts.length>best.length) best=pts; } }
    return best||[]; }
  function drawPoly(pts,color,wid){ if(pts.length<6) return;
    ctx.lineJoin='round'; ctx.lineCap='round';
    ctx.strokeStyle='#000'; ctx.lineWidth=wid+2; ctx.beginPath();
    ctx.moveTo(pts[0][0],pts[0][1]); for(const [x,y] of pts) ctx.lineTo(x,y); ctx.stroke();
    ctx.strokeStyle=color; ctx.lineWidth=wid; ctx.beginPath();
    ctx.moveTo(pts[0][0],pts[0][1]); for(const [x,y] of pts) ctx.lineTo(x,y); ctx.stroke(); }
  const g0=toGray(src);
  const passes=Math.max(1,Math.min(5,Math.round((detail-1)/2)));   // 3..15 -> ~1..5
  const g1=blur3(g0,passes);
  const thr=Math.max(0.15,Math.min(0.9,edgeVal/255));
  const bin=sobel(g1,thr);
  const sk=thinZS(bin);
  const yH0=0,yH1=Math.floor(h*0.30),yD0=yH1,yD1=Math.floor(h*0.55),yL0=yD1,yL1=h;
  // faint edges
  const overlay=ctx.createImageData(w,h);
  for(let i=0,j=0;i<bin.length;i++,j+=4) if(bin[i]){ overlay.data[j]=0; overlay.data[j+1]=255; overlay.data[j+2]=255; overlay.data[j+3]=110; }
  ctx.putImageData(overlay,0,0);
  const heart=pickLongest(sk,yH0,yH1), head=pickLongest(sk,yD0,yD1), life=pickLongest(sk,yL0,yL1);
  drawPoly(heart,'#ff3b3b',4); drawPoly(head,'#ffa533',4); drawPoly(life,'#42ff6c',4);
}
</script>
</body>
</html>
