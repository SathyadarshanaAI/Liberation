<!DOCTYPE html>
<html lang="si">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Palmistry AI Overlay ‚Äî Sathyadarshana (FULL)</title>
<style>
:root{--pri:#16f0a7;--bg:#0b0f16;--neon:#00e5ff}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:#e6f0ff;font-family:system-ui;text-align:center}
h1{margin:14px 0 6px}
.wrap{position:relative;display:inline-block}
video,canvas{width:92vw;max-width:440px;border-radius:16px;border:2px solid var(--pri);display:block;margin:auto;background:#000}
svg.overlay{position:absolute;inset:0;pointer-events:none;opacity:.6}
.captureBtn{
 position:absolute;bottom:18px;left:50%;transform:translateX(-50%);
 width:86px;height:86px;border-radius:50%;border:none;background:#2196f3;color:#000;
 font-weight:700;box-shadow:0 0 15px #2196f333;cursor:pointer
}
.btns{margin:10px 0;display:flex;gap:8px;justify-content:center;flex-wrap:wrap}
button,.btnLike{border:none;border-radius:10px;padding:.6em 1em;font-weight:700;cursor:pointer}
.left{background:#16243a;color:#cfe9ff}
.an{background:var(--pri);color:#002}
.cap{background:#fbbf24;color:#111}
.torch{background:#22c55e;color:#021}
select.btnLike,input[type=file].btnLike{background:#19283f;color:#cfe9ff}
.sliderRow{display:flex;gap:12px;justify-content:center;align-items:center;flex-wrap:wrap;margin:10px 0 6px}
.sliderRow label{display:flex;gap:8px;align-items:center}
input[type=range]{accent-color:#16f0a7}
#status{margin:10px auto;padding:10px;border:1px dashed #355;border-radius:10px;color:#cfe;max-width:760px;display:none}
footer{color:var(--pri);margin:18px 0 22px;font-size:.9em}
</style>

<!-- OpenCV loader + fallback -->
<script>
(function(){
  let loaded=false;
  function load(url, onload){
    const s=document.createElement('script'); s.src=url; s.async=true;
    s.onload=onload; s.onerror=()=>console.warn('Load failed:',url);
    document.head.appendChild(s);
  }
  load("https://docs.opencv.org/4.x/opencv.js", ()=>{
    if(window.cv){ cv['onRuntimeInitialized']=()=>{ window.cvReady=true; console.log('‚úÖ OpenCV ready'); }; loaded=true; }
  });
  // fallback after 2s if not ready
  setTimeout(()=>{
    if(!loaded || !window.cv){
      load("https://cdn.jsdelivr.net/npm/@techstark/opencv-js@4.9.0-1/opencv.min.js", ()=>{
        if(window.cv){ cv['onRuntimeInitialized']=()=>{ window.cvReady=true; console.log('‚úÖ OpenCV fallback ready'); }; }
      });
    }
  }, 2000);
})();
</script>
</head>
<body>
<h1>üñêÔ∏è Palmistry AI Overlay</h1>
<p>Align palm ‚Üí <b>Start/Choose</b> ‚Üí <b>Capture</b> ‚Üí <b>Analyze</b></p>

<div class="wrap">
  <video id="cam" playsinline muted></video>
  <canvas id="cv"></canvas>

  <!-- palm guide -->
  <svg class="overlay" viewBox="0 0 420 560" preserveAspectRatio="xMidYMid slice">
    <path d="M145 485c-55-35-78-139-19-190 6-45 8-90 29-98 
             22-9 34 33 34 79 0-52 16-96 37-95 21 1 22 47 17 98 
             7-50 24-89 43-85 19 4 19 54 9 101 8-43 25-73 42-67 
             16 6 14 49 0 96 24 22 36 71 21 110-21 55-80 74-213 51z"
          fill="none" stroke="var(--neon)" stroke-width="2" filter="drop-shadow(0 0 5px var(--neon))"/>
  </svg>

  <button class="captureBtn" id="capBtn">Capture</button>
</div>

<div class="btns">
  <button class="btnLike" id="startBtn">‚ñ∂Ô∏è Start Camera</button>
  <select id="camsel" class="btnLike"></select>
  <input id="pick" type="file" accept="image/*" class="btnLike"/>
  <button class="left" id="flipBtn">üñê Left ¬∑ Right</button>
  <button class="torch" id="torchBtn" hidden>üî¶ Torch</button>
  <button class="an" id="anBtn">‚ú® Analyze</button>
  <button class="cap" id="saveBtn">üíæ Save</button>
  <button class="btnLike" id="clearBtn">üßπ Clear</button>
</div>

<div class="sliderRow">
  <label>Edge <input id="edge" type="range" min="30" max="120" value="70"></label>
  <label>Detail <input id="gk" type="range" min="3" max="15" step="2" value="9"></label>
</div>

<div id="status"></div>

<footer>¬© 2025 Sathyadarshana ¬∑ Palmistry AI Overlay</footer>

<script>
/* ========================= CORE VARS ========================= */
const video = document.getElementById('cam'),
      canvas = document.getElementById('cv'),
      ctx    = canvas.getContext('2d');
const startBtn = document.getElementById('startBtn'),
      camsel   = document.getElementById('camsel'),
      pick     = document.getElementById('pick'),
      flipBtn  = document.getElementById('flipBtn'),
      torchBtn = document.getElementById('torchBtn'),
      capBtn   = document.getElementById('capBtn'),
      anBtn    = document.getElementById('anBtn'),
      saveBtn  = document.getElementById('saveBtn'),
      clearBtn = document.getElementById('clearBtn');
let stream=null, track=null, flipped=false, captured=false;
window.cvReady=false;
canvas.crossOrigin = video.crossOrigin = "anonymous";

function msg(t){ const s=document.getElementById('status'); s.textContent=t; s.style.display='block'; }

/* ======================= CAMERA HELPERS ====================== */
async function listCams(){
  try{
    const devs = await navigator.mediaDevices.enumerateDevices();
    const cams = devs.filter(d=>d.kind==='videoinput');
    camsel.innerHTML='';
    cams.forEach((c,i)=>{
      const o=document.createElement('option');
      o.value=c.deviceId; o.textContent=c.label||`Camera ${i+1}`;
      camsel.appendChild(o);
    });
  }catch(e){ msg('‚ÑπÔ∏è enumerateDevices failed: '+e.message); }
}
async function startCam(deviceId=null){
  if(stream){ stream.getTracks().forEach(t=>t.stop()); }
  const constraints = deviceId
    ? {video:{deviceId:{exact:deviceId},width:{ideal:1280},height:{ideal:720}},audio:false}
    : {video:{facingMode:'environment',width:{ideal:1280},height:{ideal:720}},audio:false};

  stream = await navigator.mediaDevices.getUserMedia(constraints);
  video.srcObject = stream; await video.play();
  track = stream.getVideoTracks()[0];
  const caps = track.getCapabilities?.(); if(caps && 'torch' in caps) torchBtn.hidden=false;

  canvas.width  = video.videoWidth  || 1280;
  canvas.height = video.videoHeight || 720;

  msg('‚úÖ Camera started. ‡∂Ø‡∑ê‡∂±‡∑ä Capture ‚Üí Analyze ‡∂ö‡∂ª‡∂±‡∑ä‡∂±.');
}
startBtn.onclick = async ()=>{
  try { await listCams(); const id=camsel.value||null; await startCam(id); }
  catch(e){
    if(e.name==='NotAllowedError') msg('‚ùå Permission blocked. Address bar üîí ‚Üí Site settings ‚Üí Camera ‚Üí Allow.');
    else if(e.name==='NotReadableError') msg('‚ùå Camera busy by another app. Close other apps using camera/flash.');
    else msg('‚ùå Camera error: '+e.message);
  }
};

flipBtn.onclick = ()=>{ flipped=!flipped; video.style.transform=flipped?'scaleX(-1)':'none'; };
torchBtn.onclick = async()=>{
  if(!track) return;
  try {
    const st = track.getSettings();
    await track.applyConstraints({advanced:[{torch: !st.torch}]});
  } catch(e) { msg('Torch error: '+e.message); }
};

/* ======================== CAPTURE / LOAD ===================== */
capBtn.onclick = async ()=>{
  try{
    if(!stream){ msg('‚ÑπÔ∏è Start Camera first (‡∑Ñ‡∑ù Choose file).'); return; }
    canvas.width  = video.videoWidth  || canvas.width || 1280;
    canvas.height = video.videoHeight || canvas.height|| 720;
    ctx.save(); if(flipped){ ctx.translate(canvas.width,0); ctx.scale(-1,1); }
    ctx.drawImage(video,0,0,canvas.width,canvas.height);
    ctx.restore(); captured=true;
    msg('üñêÔ∏è Photo locked. ‚ú® Analyze ‡∂ö‡∂ª‡∂±‡∑ä‡∂±.');
  }catch(e){ msg('‚ùå Capture failed: '+e.message); }
};

pick.onchange = e=>{
  const file = e.target.files?.[0]; if(!file) return;
  const img=new Image(); img.onload=()=>{
    canvas.width=img.naturalWidth; canvas.height=img.naturalHeight;
    ctx.drawImage(img,0,0,canvas.width,canvas.height); captured=true;
    msg('üñºÔ∏è Photo loaded. ‚ú® Analyze ‡∂î‡∂∂‡∂±‡∑ä‡∂±.');
  };
  img.onerror=()=>msg('‚ùå Image load failed.');
  img.src=URL.createObjectURL(file);
};

clearBtn.onclick = ()=>{ ctx.clearRect(0,0,canvas.width,canvas.height); captured=false; msg('üßπ Cleared. Ready.'); };
saveBtn.onclick  = ()=>{ if(!captured) return msg('Capture/Load first.');
  const a=document.createElement('a'); a.href=canvas.toDataURL('image/png'); a.download='palm_'+Date.now()+'.png'; a.click(); };

/* =========================== ANALYZE ========================= */
anBtn.onclick = ()=>{
  if(!captured) return alert('Capture or Choose Photo first');
  if(!window.cvReady) return alert('OpenCV is still loading‚Ä¶');
  analyzeV2();
};

function analyzeV2(){
  const edgeVal = parseInt(document.getElementById('edge').value, 10); // 30..120
  const gk = parseInt(document.getElementById('gk').value, 10) | 1;    // odd 3..15

  // 0) read canvas -> src
  const src = cv.imread(canvas);
  const h = src.rows, w = src.cols;

  // 1) gray + CLAHE + blur
  const gray = new cv.Mat();
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
  const clahe = new cv.CLAHE(2.0, new cv.Size(8,8));
  clahe.apply(gray, gray);
  cv.GaussianBlur(gray, gray, new cv.Size(gk, gk), 0, 0, cv.BORDER_DEFAULT);

  // 2) edges via Canny
  const low = Math.max(10, edgeVal);
  const high = Math.min(255, Math.round(edgeVal * 2));
  const edges = new cv.Mat();
  cv.Canny(gray, edges, low, high);

  // 3) bands: Heart 0-30%, Head 30-55%, Life 55-100%
  const yHeart0 = 0,         yHeart1 = Math.round(h * 0.30);
  const yHead0  = yHeart1,   yHead1  = Math.round(h * 0.55);
  const yLife0  = yHead1,    yLife1  = h;

  function longestContour(y0, y1){
    const roi = edges.roi(new cv.Rect(0, y0, w, y1 - y0));
    const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3,3));
    cv.morphologyEx(roi, roi, cv.MORPH_OPEN, kernel);
    const contours = new cv.MatVector(), hier = new cv.Mat();
    cv.findContours(roi, contours, hier, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_NONE);

    let best = null, bestLen = 0;
    for (let i=0;i<contours.size();i++){
      const c = contours.get(i), len = cv.arcLength(c,false);
      if (len > bestLen && len > 40) { best=c; bestLen=len; }
    }
    const pts=[];
    if(best){
      const approx=new cv.Mat();
      cv.approxPolyDP(best, approx, 2.0, false);
      for(let i=0;i<approx.rows;i++){
        const p=approx.intPtr(i);
        pts.push([p[0], p[1]+y0]);
      }
      approx.delete();
    }
    contours.delete(); hier.delete(); roi.delete(); kernel.delete();
    return pts;
  }

  const heartPts = longestContour(yHeart0,yHeart1);
  const headPts  = longestContour(yHead0 ,yHead1 );
  const lifePts  = longestContour(yLife0 ,yLife1 );

  function drawPoly(pts, bgr){
    if(!pts || pts.length<4) return;
    const col = new cv.Scalar(bgr[0], bgr[1], bgr[2], 255);
    for(let i=1;i<pts.length;i++){
      cv.line(src, new cv.Point(pts[i-1][0], pts[i-1][1]),
                   new cv.Point(pts[i][0],   pts[i][1]), col, 4, cv.LINE_AA);
    }
  }
  drawPoly(heartPts,[ 60, 60,255]); // red-ish
  drawPoly(headPts ,[ 60,180,255]); // orange-ish
  drawPoly(lifePts ,[ 60,255,120]); // green-ish

  // faint cyan edges overlay for context
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      if(edges.ucharPtr(y,x)[0]){
        const px=src.ucharPtr(y,x);
        px[0]=Math.min(255, (px[0]*0.6 + 255*0.4)); // B
        px[1]=Math.min(255, (px[1]*0.6 + 255*0.4)); // G
      }
    }
  }

  cv.imshow(canvas, src);
  [src, gray, clahe, edges].forEach(m=>m.delete());
  msg('‚úÖ Analyze complete. Edge='+edgeVal+' ¬∑ Detail='+gk);
}
</script>
</body>
</html>
