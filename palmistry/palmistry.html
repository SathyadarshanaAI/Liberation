<!DOCTYPE html>
<html lang="si">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Palmistry ‚Äì AI Overlay (Lebetion)</title>
  <style>
    :root{--pri:#16f0a7;--sec:#38bdf8}
    body{margin:0;background:#0b0f16;color:#e6f0ff;font-family:system-ui,Segoe UI,Inter,Arial,sans-serif;text-align:center}
    h1{margin:16px 0 6px}
    .wrap{display:inline-block;position:relative;margin:10px auto}
    video,canvas{width:92vw;max-width:420px;border-radius:16px;border:2px solid var(--pri);display:block;background:#0e1625}
    .ghost{position:absolute;inset:0;width:100%;height:100%;opacity:.32;pointer-events:none}
    .btns{margin:12px 0 14px;display:flex;gap:10px;justify-content:center;flex-wrap:wrap}
    button{border:none;border-radius:10px;padding:.6em 1.1em;font-weight:700;cursor:pointer}
    .flip{background:#16243a;color:#cfe9ff}
    .cap{background:var(--sec);color:#07121f}
    .an{background:var(--pri);color:#07121f}
    .save{background:#fbbf24;color:#111827}
    .hint{color:#a6c8ff;margin:6px 0 2px}
    .row{display:flex;gap:8px;justify-content:center;align-items:center;flex-wrap:wrap}
    .chip{background:#0f172a;border:1px solid #1f2c48;border-radius:999px;padding:.25em .6em}
    .sl{width:180px}
    footer{color:var(--pri);margin:18px 0 22px;font-size:.95em}
  </style>

  <!-- OpenCV.js with fallback -->
  <script>
    (function loadCV(){
      const primary ="https://docs.opencv.org/4.x/opencv.js";
      const fallback="https://cdn.jsdelivr.net/npm/@techstark/opencv-js@4.9.0-1/opencv.min.js";
      const s=document.createElement('script');
      s.src=primary; s.async=true;
      s.onerror=()=>{console.warn("Primary OpenCV CDN failed ‚Äî using fallback");
        const f=document.createElement('script'); f.src=fallback; f.async=true; document.head.appendChild(f);
      };
      document.head.appendChild(s);
    })();
  </script>
</head>
<body>
  <h1>üñêÔ∏è Palmistry ‚Äì AI Overlay</h1>

  <div class="wrap">
    <video id="cam" autoplay playsinline muted></video>
    <img class="ghost" src="https://i.ibb.co/1K7K0gF/palm-overlay-demo.png" alt="overlay"
         onerror="this.style.display='none'">
    <canvas id="cv"></canvas>
  </div>

  <p class="hint">‡∂Ö‡∂≠ overlay ‡∂ë‡∂ö‡∂ß align ‡∂ö‡∂ª‡∂Ω‡∑è <b>Capture ‚Üí Analyze</b> ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</p>

  <div class="btns">
    <button class="flip" id="flipBtn">‚ÜîÔ∏è Flip</button>
    <button class="cap"  id="capBtn">üì∏ Capture</button>
    <button class="an"   id="anBtn" disabled title="Loading OpenCV‚Ä¶">‚ú® Analyze</button>
    <button class="save" id="saveBtn" disabled>üíæ Save PNG</button>
  </div>

  <div class="row">
    <span class="chip">Edge: <input id="th1" class="sl" type="range" min="20" max="120" value="60"> <small id="th1v">60</small></span>
    <span class="chip">Detail: <input id="gk" class="sl" type="range" min="7" max="23" step="2" value="15"> <small id="gkv">15</small></span>
  </div>

  <footer>¬© 2025 Lebetion ¬∑ Sathyadarshana ‚Äì Palmistry AI Overlay</footer>

<script>
const video  = document.getElementById('cam');
const canvas = document.getElementById('cv');
const ctx    = canvas.getContext('2d');
const flipBtn= document.getElementById('flipBtn');
const capBtn = document.getElementById('capBtn');
const anBtn  = document.getElementById('anBtn');
const saveBtn= document.getElementById('saveBtn');
const th1El  = document.getElementById('th1');
const gkEl   = document.getElementById('gk');
const th1v   = document.getElementById('th1v');
const gkv    = document.getElementById('gkv');

let flipped=false, captured=false;

// camera
navigator.mediaDevices?.getUserMedia({video:{facingMode:"environment"}})
  .then(s=>video.srcObject=s)
  .catch(()=>alert("üì∑ Camera unavailable or blocked"));

function fit(){ const w=Math.min(420, Math.floor(innerWidth*0.92)); const h=Math.floor(w*4/3); canvas.width=w; canvas.height=h; }
addEventListener('resize', fit, {passive:true}); fit();

flipBtn.onclick=()=>{ flipped=!flipped; video.style.transform = flipped?'scaleX(-1)':'none'; };

capBtn.onclick=()=>{
  if(video.videoWidth===0) return alert('Video not ready');
  canvas.width=video.videoWidth; canvas.height=video.videoHeight;
  ctx.save(); if(flipped){ ctx.translate(canvas.width,0); ctx.scale(-1,1); }
  ctx.drawImage(video,0,0,canvas.width,canvas.height); ctx.restore();
  captured=true; anBtn.disabled=false; saveBtn.disabled=false;
};

// Save
saveBtn.onclick=()=>{
  const url = canvas.toDataURL('image/png');
  const a=document.createElement('a'); a.href=url; a.download='palm_overlay_'+Date.now()+'.png'; a.click();
};

// sliders UI
th1El.oninput=()=>th1v.textContent=th1El.value;
gkEl.oninput =()=>gkv.textContent=gkEl.value;

// OpenCV ready gate
(function waitForCV(){
  const ready=()=>{ console.log("‚úÖ OpenCV ready"); anBtn.disabled=false; anBtn.title=""; };
  const poll = ()=> (window.cv && cv.Mat) ? ready() : setTimeout(poll,200);
  if (window.cv && cv['onRuntimeInitialized']!==undefined){ cv['onRuntimeInitialized']=ready; poll(); }
  else { poll(); }
})();

// ---------- ANALYZE ----------
anBtn.onclick = ()=> {
  if (!captured) return alert('Capture first!');
  if (!window.cv || !cv.Mat) return alert('OpenCV.js not loaded yet');
  analyze();
};

function analyze(){
  const src = cv.imread(canvas);

  /* 1) Palm ROI using skin mask (YCrCb) + largest contour */
  const ycrcb = new cv.Mat(); cv.cvtColor(src, ycrcb, cv.COLOR_RGBA2YCrCb);
  const low  = new cv.Mat(ycrcb.rows, ycrcb.cols, ycrcb.type(), [0,133,77,0]);
  const high = new cv.Mat(ycrcb.rows, ycrcb.cols, ycrcb.type(), [255,173,127,255]);
  const skin = new cv.Mat(); cv.inRange(ycrcb, low, high, skin);
  cv.medianBlur(skin, skin, 5);
  let k5 = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(7,7));
  cv.morphologyEx(skin, skin, cv.MORPH_CLOSE, k5);
  const contours = new cv.MatVector(), hier = new cv.Mat();
  cv.findContours(skin, contours, hier, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
  let maxA=0, idx=-1; for(let i=0;i<contours.size();i++){ const a=cv.contourArea(contours.get(i)); if(a>maxA){maxA=a; idx=i;} }
  const handMask = cv.Mat.zeros(src.rows, src.cols, cv.CV_8U);
  if(idx>=0) cv.drawContours(handMask, contours, idx, new cv.Scalar(255), -1);

  /* 2) Enhance lines (CLAHE + Gabor bank) */
  const gray = new cv.Mat(); cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
  const clahe = new cv.CLAHE(2.0, new cv.Size(8,8)); clahe.apply(gray, gray);

  const ksize = Math.max(7, (+gkEl.value|0)); // odd size
  const sigma=4.0, lambd=10.0, gamma=0.5, psi=0;
  const angles=[0,20,40,60,80,100,120,140];
  const gSum = new cv.Mat.zeros(gray.rows, gray.cols, cv.CV_32F);
  let resp = new cv.Mat();
  for(const d of angles){
    const th=d*Math.PI/180;
    const kern=cv.getGaborKernel(new cv.Size(ksize,ksize),sigma,th,lambd,gamma,psi,cv.CV_32F);
    cv.filter2D(gray, resp, cv.CV_32F, kern);
    cv.max(gSum, resp, gSum);
    kern.delete();
  }
  const g8=new cv.Mat(); cv.normalize(gSum,gSum,0,255,cv.NORM_MINMAX); gSum.convertTo(g8,cv.CV_8U);

  /* 3) Binarize + clean + thin */
  cv.bitwise_and(g8, handMask, g8); // keep palm only
  const bin=new cv.Mat();
  cv.adaptiveThreshold(g8, bin, 255, cv.ADAPTIVE_THRESH_MEAN_C, cv.THRESH_BINARY, 21, -(+(th1El.value)));
  const k3=cv.getStructuringElement(cv.MORPH_RECT,new cv.Size(3,3));
  cv.morphologyEx(bin, bin, cv.MORPH_CLOSE, k3);
  cv.erode(bin, bin, k3);

  /* 4) Skeletonize */
  const skel = skeletonize(bin);

  /* 5) Trace & draw smooth bold polylines (neon cyan) */
  const cts=new cv.MatVector(), hr2=new cv.Mat();
  cv.findContours(skel, cts, hr2, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_NONE);
  const out = src.clone();
  for(let i=0;i<cts.size();i++){
    const cnt=cts.get(i);
    if (cnt.total()<45){ cnt.delete(); continue; }
    const approx=new cv.Mat();
    cv.approxPolyDP(cnt, approx, 2, false);
    cv.drawContours(out, new cv.MatVector(approx), 0, new cv.Scalar(255,255,0,255), 2);
    approx.delete(); cnt.delete();
  }

  cv.imshow(canvas, out);

  // cleanup
  [ycrcb,low,high,skin,contours,hier,handMask,gray,clahe,gSum,g8,resp,bin,k5,k3,skel,cts,hr2,out].forEach(m=>{try{m.delete()}catch(e){}});
}

/* helper: morphological skeletonization */
function skeletonize(bin){
  const skel=cv.Mat.zeros(bin.rows,bin.cols,cv.CV_8U);
  const element=cv.getStructuringElement(cv.MORPH_CROSS,new cv.Size(3,3));
  const temp=new cv.Mat(), er=new cv.Mat();
  while(true){
    cv.erode(bin,er,element);
    cv.dilate(er,temp,element);
    cv.subtract(bin,temp,temp);
    cv.bitwise_or(skel,temp,skel);
    er.copyTo(bin);
    if(cv.countNonZero(bin)===0)break;
  }
  temp.delete(); er.delete(); element.delete();
  return skel;
}
</script>
</body>
</html>
