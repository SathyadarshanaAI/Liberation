<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/>
<title>Palmistry Research · Ridge + Lines</title>
<style>
  :root{--pri:#16f0a7;--neon:#00e5ff;--bg:#0b0f16;--ink:#e6f0ff;--card:#0f1420;--muted:#9fb3c8;--err:#ff6b6b}
  *{box-sizing:border-box} body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui}
  main{max-width:980px;margin:auto;padding:14px}
  h1{margin:8px 0 2px}
  .row{display:flex;gap:12px;flex-wrap:wrap}
  .card{flex:1 1 460px;background:var(--card);border:1px solid #122136;border-radius:16px;padding:10px;box-shadow:0 0 0 1px #0a1520 inset}
  .stage{position:relative;display:grid;place-items:center}
  video,canvas{width:100%;max-width:460px;border-radius:16px;border:2px solid var(--pri);background:#000}
  .overlay{position:absolute;inset:10px;pointer-events:none;opacity:.55}
  button{background:linear-gradient(180deg,var(--neon),var(--pri));color:#001315;border:none;border-radius:12px;padding:10px 14px;font-weight:700;cursor:pointer}
  button.secondary{background:#0f2033;color:#d7ecff;border:1px solid #29465f}
  button:disabled{opacity:.45;cursor:not-allowed}
  select,input[type=range],input[type=color]{background:#091120;color:var(--ink);border:1px solid #2a405a;border-radius:10px;padding:6px 8px}
  #status{border:1px dashed #35597a;border-radius:10px;padding:8px 10px;min-height:42px;color:var(--muted)}
  footer{margin:14px 0 6px;text-align:center;color:#9db3c8}
  small{color:var(--muted)}
</style>
</head>
<body>
<main>
  <h1>Palmistry Research <small>· Ridge map + Colored lines (offline)</small></h1>

  <div class="row">
    <section class="card">
      <div class="stage">
        <video id="cam" playsinline muted></video>
        <canvas id="overlay" class="overlay"></canvas>
      </div>

      <div class="row" style="margin-top:6px">
        <button id="startBtn">Start</button>
        <button id="captureBtn" class="secondary">Capture</button>
        <button id="analyzeBtn" class="secondary">Analyze</button>
        <button id="clearBtn" class="secondary">Clear</button>
      </div>

      <div class="row" style="margin-top:6px">
        <label>Resolution
          <select id="resSel">
            <option value="1920x1080">1920×1080</option>
            <option value="1280x720" selected>1280×720</option>
            <option value="960x540">960×540</option>
          </select>
        </label>
        <label>FPS
          <select id="fpsSel">
            <option>60</option><option selected>30</option><option>24</option>
          </select>
        </label>
        <label>Edge <input id="edge" type="range" min="40" max="120" value="80"></label>
      </div>

      <div class="row" style="margin-top:6px">
        <label>Line color <input id="lineColor" type="color" value="#00ffe8"></label>
        <label>Thickness <input id="thick" type="range" min="1" max="6" value="3"></label>
        <label>Ridge alpha <input id="ridgeA" type="range" min="0" max="60" value="35"></label>
        <label><input id="stylize" type="checkbox" checked> Stylize palm only</label>
      </div>

      <hr/>
      <div id="status">Press <b>Start</b> — back camera, please.</div>
    </section>

    <section class="card">
      <canvas id="capture" width="0" height="0" aria-label="Output"></canvas>
      <hr/>
      <h3>AI Summary</h3>
      <div id="aiText" style="color:var(--muted)">Capture → Analyze to see ridge + colored lines over a blue background.</div>
    </section>
  </div>

  <footer>© Sathyadarshana · Research build · Works offline</footer>
</main>

<script>
/* ---------- Utilities ---------- */
const $ = s => document.querySelector(s);
const log = (m,t="info")=>{
  const c = t==="error"?"var(--err)":t==="warn"?"#ffcc66":"var(--muted)";
  $("#status").innerHTML = `<span style="color:${c}">${m}</span>`;
  console[t==="error"?"error":t==="warn"?"warn":"log"]("[Palm]",m);
};
let stream=null, track=null;
const cam=$("#cam"), overlay=$("#overlay"), octx=overlay.getContext("2d");
const cap=$("#capture"), cctx=cap.getContext("2d");

/* ---------- Camera ---------- */
function constraints(){
  const [w,h] = $("#resSel").value.split("x").map(Number);
  const fps = +$("#fpsSel").value;
  return {audio:false, video:{
    width:{ideal:w}, height:{ideal:h}, frameRate:{ideal:fps},
    facingMode:{ exact:"environment" } // back cam
  }};
}
async function startCamera(){
  try{
    if(stream) stopCamera();
    stream = await navigator.mediaDevices.getUserMedia(constraints());
    cam.srcObject = stream; await cam.play(); track=stream.getVideoTracks()[0];
    fitOverlay(); log(`Camera started · ${track.label||"video"} · ${cam.videoWidth}×${cam.videoHeight}@${$("#fpsSel").value}fps`);
    drawOverlayLoop();
  }catch(e){ log("Camera failed: "+e.message, "error"); }
}
function stopCamera(){ try{stream?.getTracks().forEach(t=>t.stop());}catch{} stream=null; track=null; }
function fitOverlay(){
  const r=cam.getBoundingClientRect(); overlay.width=r.width; overlay.height=r.height;
}
let rafId=null;
function drawOverlayLoop(){
  cancelAnimationFrame(rafId);
  const pad=10;
  const draw=()=>{
    octx.clearRect(0,0,overlay.width,overlay.height);
    octx.strokeStyle="rgba(0,229,255,.9)"; octx.lineWidth=2;
    octx.strokeRect(pad,pad,overlay.width-2*pad,overlay.height-2*pad);
    octx.setLineDash([6,6]); octx.strokeStyle="rgba(22,240,167,.9)"; octx.lineWidth=1.5;
    octx.beginPath();
    octx.moveTo(overlay.width/2,pad); octx.lineTo(overlay.width/2,overlay.height-pad);
    octx.moveTo(pad,overlay.height/2); octx.lineTo(overlay.width-pad,overlay.height/2); octx.stroke();
    octx.setLineDash([]);
    rafId=requestAnimationFrame(draw);
  }; draw();
}
window.addEventListener("resize",()=>setTimeout(fitOverlay,100),{passive:true});

/* ---------- Capture ---------- */
function captureFrame(){
  if(!cam.videoWidth){ log("Camera not ready", "warn"); return; }
  cap.width=cam.videoWidth; cap.height=cam.videoHeight;
  cctx.drawImage(cam,0,0,cap.width,cap.height);
  $("#aiText").innerHTML="Captured. Click <b>Analyze</b>.";
  log("Captured frame.");
}

/* ---------- Math helpers ---------- */
const hex2rgb=h=>({r:parseInt(h.slice(1,3),16),g:parseInt(h.slice(3,5),16),b:parseInt(h.slice(5,7),16)});
function rgb2ycbcr(r,g,b){
  const Y=0.299*r+0.587*g+0.114*b;
  const Cb=-0.168736*r-0.331264*g+0.5*b+128;
  const Cr=0.5*r-0.418688*g-0.081312*b+128;
  return [Y,Cb,Cr];
}

/* ---------- Palm mask (YCbCr + largest component) ---------- */
function makePalmMask(img,w,h){
  const mask=new Uint8Array(w*h);
  for(let i=0,j=0;i<img.data.length;i+=4,j++){
    const r=img.data[i], g=img.data[i+1], b=img.data[i+2];
    const [Y,Cb,Cr]=rgb2ycbcr(r,g,b);
    mask[j] = (Cr>135 && Cr<180 && Cb>85 && Cb<135 && Y>40) ? 1:0; // generic skin window
  }
  // simple open-close 3x3
  const tmp=new Uint8Array(mask), idx=(x,y)=>y*w+x;
  for(let y=1;y<h-1;y++)for(let x=1;x<w-1;x++){ // erode
    let keep=1; for(let yy=-1;yy<=1;yy++)for(let xx=-1;xx<=1;xx++) keep&=tmp[idx(x+xx,y+yy)];
    mask[idx(x,y)]=keep;
  }
  tmp.set(mask);
  for(let y=1;y<h-1;y++)for(let x=1;x<w-1;x++){ // dilate
    let v=0; for(let yy=-1;yy<=1;yy++)for(let xx=-1;xx<=1;xx++) v|=tmp[idx(x+xx,y+yy)];
    mask[idx(x,y)]=v;
  }
  // largest component
  const lab=new Int32Array(w*h).fill(-1);
  let best=-1,bestArea=0,cur=0; const qx=new Int32Array(w*h), qy=new Int32Array(w*h);
  for(let y=0;y<h;y++)for(let x=0;x<w;x++){
    const i=idx(x,y); if(!mask[i]||lab[i]>=0) continue;
    let head=0,tail=0,area=0; qx[tail]=x; qy[tail]=y; tail++; lab[i]=cur;
    while(head<tail){
      const cx=qx[head], cy=qy[head]; head++; area++;
      for(const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
        const nx=cx+dx, ny=cy+dy; if(nx<0||ny<0||nx>=w||ny>=h) continue;
        const ni=idx(nx,ny); if(mask[ni] && lab[ni]<0){ lab[ni]=cur; qx[tail]=nx; qy[tail]=ny; tail++; }
      }
    }
    if(area>bestArea){bestArea=area;best=cur;} cur++;
  }
  const out=new Uint8Array(w*h); if(best>=0) for(let i=0;i<lab.length;i++) out[i]=(lab[i]===best)?1:0;
  return out;
}

/* ---------- Sobel edges (for palm lines) ---------- */
function sobelEdges(gray,w,h,th){
  const out=new Uint8ClampedArray(w*h);
  const kx=[-1,0,1,-2,0,2,-1,0,1], ky=[-1,-2,-1,0,0,0,1,2,1];
  for(let y=1;y<h-1;y++)for(let x=1;x<w-1;x++){
    let gx=0,gy=0,k=0;
    for(let yy=-1;yy<=1;yy++)for(let xx=-1;xx<=1;xx++){
      const p=gray[(y+yy)*w+(x+xx)];
      gx+=p*kx[k]; gy+=p*ky[k]; k++;
    }
    out[y*w+x] = (Math.hypot(gx,gy)>th)?255:0;
  }
  return out;
}
function dilate(bin,w,h,it=1){
  const idx=(x,y)=>y*w+x;
  for(let t=0;t<it;t++){
    const cp=new Uint8ClampedArray(bin);
    for(let y=1;y<h-1;y++)for(let x=1;x<w-1;x++){
      if(cp[idx(x,y)]) continue; let hit=0;
      for(let yy=-1;yy<=1;yy++){for(let xx=-1;xx<=1;xx++){ if(cp[idx(x+xx,y+yy)]){hit=1;break;} } if(hit)break;}
      if(hit) bin[idx(x,y)]=255;
    }
  }
}

/* ---------- Orientation field + directional ridge response ---------- */
function orientationField(gray,w,h){
  const Gx=[-1,0,1,-2,0,2,-1,0,1], Gy=[-1,-2,-1,0,0,0,1,2,1];
  const ox=new Float32Array(w*h), oy=new Float32Array(w*h);
  for(let y=1;y<h-1;y++)for(let x=1;x<w-1;x++){
    let gx=0,gy=0,k=0;
    for(let yy=-1;yy<=1;yy++)for(let xx=-1;xx<=1;xx++){
      const p=gray[(y+yy)*w+(x+xx)];
      gx+=p*Gx[k]; gy+=p*Gy[k]; k++;
    }
    ox[y*w+x]=gx*gx-gy*gy; oy[y*w+x]=2*gx*gy;
  }
  const ang=new Float32Array(w*h);
  for(let i=0;i<w*h;i++) ang[i]=0.5*Math.atan2(oy[i],ox[i]);
  return ang;
}
function dirKernel(theta,s=2){
  const k=[],R=3, ct=Math.cos(theta), st=Math.sin(theta);
  for(let y=-R;y<=R;y++)for(let x=-R;x<=R;x++){
    const u=x*ct+y*st, v=-x*st+y*ct; // along, across
    const g1=Math.exp(-(v*v)/(2*s*s));
    const g2=Math.exp(-(v*v)/(2*(s*1.6)*(s*1.6)));
    k.push(g1-g2);
  }
  // normalize
  let m=0; for(const v of k) m+=v; m/=k.length;
  let sd=0; for(const v of k) sd+=(v-m)*(v-m); sd=Math.sqrt(sd/k.length)||1;
  for(let i=0;i<k.length;i++) k[i]=(k[i]-m)/sd;
  return {k,R};
}
function ridgeResponse(gray,ang,w,h){
  const K=8, kernels=[]; for(let i=0;i<K;i++) kernels.push(dirKernel(i*Math.PI/K));
  const out=new Float32Array(w*h);
  for(let y=3;y<h-3;y++)for(let x=3;x<w-3;x++){
    const i=y*w+x; let a=ang[i]; if(isNaN(a)) a=0;
    let bin = Math.round((a%(Math.PI))/Math.PI*K)%K;
    const {k,R}=kernels[bin]; let s=0,p=0;
    for(let yy=-R;yy<=R;yy++)for(let xx=-R;xx<=R;xx++){
      s += gray[(y+yy)*w+(x+xx)] * k[p++]; 
    }
    out[i]=s;
  }
  // normalize 0..255
  let mn=1e9,mx=-1e9; for(const v of out){ if(v<mn)mn=v; if(v>mx)mx=v; }
  const rid=new Uint8ClampedArray(w*h), scale=255/(mx-mn||1);
  for(let i=0;i<w*h;i++) rid[i]=((out[i]-mn)*scale)|0;
  return rid;
}
function otsu(data){
  const hist=new Uint32Array(256); for(const v of data) hist[v]++;
  let sum=0,total=0; for(let i=0;i<256;i++){sum+=i*hist[i]; total+=hist[i];}
  let sumB=0,wB=0,maxV=0,thr=128;
  for(let t=0;t<256;t++){
    wB+=hist[t]; if(!wB) continue; const wF=total-wB; if(!wF) break;
    sumB+=t*hist[t]; const mB=sumB/wB, mF=(sum-sumB)/wF;
    const v=wB*wF*(mB-mF)*(mB-mF); if(v>maxV){maxV=v; thr=t;}
  } return thr;
}

/* ---------- Compose ---------- */
function composeBlue(ridgeBin,ridgeGray,palmEdges,palmMask,w,h,lineRGB,alphaPct,stylize){
  const out=cctx.createImageData(w,h);
  const B={r:16,g:38,b:180}; // blue background
  const aBase=(alphaPct|0)/100; // 0..0.6
  for(let i=0,k=0;i<w*h;i++,k+=4){
    // base blue
    out.data[k]=B.r; out.data[k+1]=B.g; out.data[k+2]=B.b; out.data[k+3]=255;

    if(!stylize || palmMask[i]){ // apply only to palm if stylize checked
      // ridge layer (soft)
      const g=ridgeGray[i]; const a = (ridgeBin[i]? aBase : aBase*0.5);
      out.data[k]   = (1-a)*out.data[k]   + a*g;
      out.data[k+1] = (1-a)*out.data[k+1] + a*g;
      out.data[k+2] = (1-a)*out.data[k+2] + a*(g+30); // cyan tint
    }else{
      // outside palm darker blue
      out.data[k]=(out.data[k]*0.7)|0; out.data[k+1]=(out.data[k+1]*0.7)|0;
    }

    // palm colored lines on top
    if(palmEdges[i]){
      out.data[k]=lineRGB.r; out.data[k+1]=lineRGB.g; out.data[k+2]=lineRGB.b;
    }
  }
  cctx.putImageData(out,0,0);
}

/* ---------- Analyze Pipeline ---------- */
function analyze(){
  if(cap.width===0){ log("No capture yet.", "warn"); return; }
  const t0=performance.now();
  const w=cap.width, h=cap.height;
  const img=cctx.getImageData(0,0,w,h);

  // grayscale
  const gray=new Uint8ClampedArray(w*h);
  for(let i=0,j=0;i<img.data.length;i+=4,j++){
    const r=img.data[i], g=img.data[i+1], b=img.data[i+2];
    gray[j]=(0.299*r+0.587*g+0.114*b)|0;
  }

  const TH=+$("#edge").value;
  const sob=sobelEdges(gray,w,h,TH);             // palm line candidates
  const palmMask=makePalmMask(img,w,h);          // keep only palm
  const palmEdges=new Uint8ClampedArray(w*h);
  for(let i=0;i<w*h;i++) palmEdges[i]=(sob[i]&&palmMask[i])?255:0;

  const thick=(+$("#thick").value)-1; if(thick>0) dilate(palmEdges,w,h,thick);

  const ang=orientationField(gray,w,h);          // fingerprint orientation
  const ridGray=ridgeResponse(gray,ang,w,h);     // ridge response (0..255)
  const thr=otsu(ridGray);                       // global Otsu
  const ridgeBin=new Uint8ClampedArray(w*h);
  for(let i=0;i<w*h;i++) ridgeBin[i]=(ridGray[i]>thr)?255:0;

  composeBlue(
    ridgeBin, ridGray, palmEdges, palmMask, w, h,
    hex2rgb($("#lineColor").value),
    +$("#ridgeA").value, $("#stylize").checked
  );

  const ms=(performance.now()-t0).toFixed(1);
  const edgeCount=palmEdges.reduce((a,b)=>a+(b?1:0),0);
  $("#aiText").innerHTML = `Ridge + colored lines ✓<br>${w}×${h}px • edges=${edgeCount.toLocaleString()} • ${ms} ms`;
  log("Analyze completed (back camera + bg filter + ridge + lines).");
}

/* ---------- Clear ---------- */
function clearAll(){
  cctx.clearRect(0,0,cap.width,cap.height);
  $("#aiText").textContent="Cleared. Capture again.";
}

/* ---------- Events ---------- */
$("#startBtn").onclick=startCamera;
$("#captureBtn").onclick=captureFrame;
$("#analyzeBtn").onclick=analyze;
$("#clearBtn").onclick=clearAll;
$("#resSel").onchange=startCamera; $("#fpsSel").onchange=startCamera;

/* ---------- Bootstrap ---------- */
(async function(){
  if(!("mediaDevices" in navigator)){ log("No camera access support.", "error"); return; }
  log("Ready. Back camera will be used (environment).");
})();
</script>
</body>
</html>
